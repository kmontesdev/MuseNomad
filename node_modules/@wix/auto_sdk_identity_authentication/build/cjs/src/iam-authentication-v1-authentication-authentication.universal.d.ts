import { NonNullablePaths } from '@wix/sdk-types';
export interface Authentication {
}
export interface RegisterV2Request {
    /** Identifier of the registering member. */
    loginId: LoginId;
    /** Password of the registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data that's relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
export interface LoginId extends LoginIdTypeOneOf {
    /**
     * Login email address.
     * @format EMAIL
     */
    email?: string;
}
/** @oneof */
export interface LoginIdTypeOneOf {
    /**
     * Login email address.
     * @format EMAIL
     */
    email?: string;
}
export interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /**
     * List of profile labels.
     * @maxSize 2000
     */
    labels?: string[];
    /**
     * Profile language.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatusWithLiterals;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /**
     * Company name.
     * @maxLength 1000
     */
    company?: string | null;
    /**
     * Position within company.
     * @maxLength 1000
     */
    position?: string | null;
    /**
     * Profile birthdate in `YYYY-MM-DD` format.
     * @format LOCAL_DATE
     */
    birthdate?: string | null;
    /**
     * Profile slug.
     * @maxLength 255
     */
    slug?: string | null;
}
export declare enum PrivacyStatus {
    /** No defined privacy status. */
    UNDEFINED = "UNDEFINED",
    /** Profile details, such as profile name and profile picture, are visible to other members. */
    PUBLIC = "PUBLIC",
    /** Profile details aren't visible to other members. */
    PRIVATE = "PRIVATE"
}
/** @enumType */
export type PrivacyStatusWithLiterals = PrivacyStatus | 'UNDEFINED' | 'PUBLIC' | 'PRIVATE';
export interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
export interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
/** @oneof */
export interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
export interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
export interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
export interface SecondaryEmail {
    /**
     * Email address.
     * @format EMAIL
     */
    email?: string;
    /** Email tag. */
    tag?: EmailTagWithLiterals;
}
export declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
/** @enumType */
export type EmailTagWithLiterals = EmailTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'WORK';
export interface Phone {
    /**
     * Phone country code.
     * @format COUNTRY
     */
    countryCode?: string | null;
    /**
     * Phone number.
     * @format PHONE
     */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTagWithLiterals;
}
export declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
/** @enumType */
export type PhoneTagWithLiterals = PhoneTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'MOBILE' | 'WORK' | 'FAX';
export interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTagWithLiterals;
}
/** Physical address */
export interface Address {
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains apartment, suite, and floor. */
    addressLine2?: string | null;
}
export declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
/** @enumType */
export type AddressTagWithLiterals = AddressTag | 'UNTAGGED' | 'HOME' | 'WORK' | 'BILLING' | 'SHIPPING';
export interface CaptchaToken extends CaptchaTokenTokenOneOf {
    /** @maxLength 5000 */
    Recaptcha?: string;
    /** @maxLength 5000 */
    InvisibleRecaptcha?: string;
    /** @maxLength 5000 */
    NoCaptcha?: string;
}
/** @oneof */
export interface CaptchaTokenTokenOneOf {
    /** @maxLength 5000 */
    Recaptcha?: string;
    /** @maxLength 5000 */
    InvisibleRecaptcha?: string;
    /** @maxLength 5000 */
    NoCaptcha?: string;
}
export interface StateMachineResponse extends StateMachineResponseStateDataOneOf {
    /** Current state of the login or registration process. */
    state?: StateTypeWithLiterals;
    /** Session token. If `state` is not `SUCCESS`, this field is undefined. */
    sessionToken?: string | null;
    /** Token that represents the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identity of the current member. */
    identity?: Identity;
    /** Additional data relevant to the login or registration process. */
    additionalData?: Record<string, CustomValue>;
}
/** @oneof */
export interface StateMachineResponseStateDataOneOf {
}
export declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** Login completed successfully. */
    SUCCESS = "SUCCESS",
    /** Indicates that the member needs the owner to approve their registration. */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /** Indicates that the member needs to verify their email. */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** Indicates that the `status` is not one that prevents the member logging in, meaning it's not `OFFLINE`, `BLOCKED`, or `DELETED`. */
    STATUS_CHECK = "STATUS_CHECK"
}
/** @enumType */
export type StateTypeWithLiterals = StateType | 'UNKNOWN_STATE' | 'SUCCESS' | 'REQUIRE_OWNER_APPROVAL' | 'REQUIRE_EMAIL_VERIFICATION' | 'STATUS_CHECK';
export interface Identity {
    /**
     * Identity ID.
     * @format GUID
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the identity is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the identity.
     *
     * Ignored when creating an identity.
     */
    revision?: string | null;
    /**
     * Date and time the identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the identity was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** Custom attributes. */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity verification factors.
     * @maxSize 10
     * @readonly
     */
    factors?: Factor[];
}
export interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
export interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
export interface IdpConnection {
    /**
     * IDP connection ID.
     * @format GUID
     */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
export interface AuthenticatorConnection {
    /**
     * Authenticator connection ID.
     * @format GUID
     */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
export interface Metadata {
    /**
     * General tags. For example, `"isOwner"`.
     * @readonly
     */
    tags?: string[];
}
export interface Email {
    /**
     * Email address.
     * @format EMAIL
     */
    address?: string;
    /** Whether the email address is verified. */
    isVerified?: boolean;
}
export interface StatusV2 {
    name?: StatusNameWithLiterals;
    reasons?: ReasonWithLiterals[];
}
export declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
/** @enumType */
export type StatusNameWithLiterals = StatusName | 'UNKNOWN_STATUS' | 'PENDING' | 'ACTIVE' | 'DELETED' | 'BLOCKED' | 'OFFLINE';
export declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
/** @enumType */
export type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'PENDING_ADMIN_APPROVAL_REQUIRED' | 'PENDING_EMAIL_VERIFICATION_REQUIRED';
export interface Factor {
    /**
     * Factor ID.
     * @format GUID
     */
    factorId?: string;
    /** Factor type. */
    type?: FactorTypeWithLiterals;
    /** Factor status. */
    status?: StatusWithLiterals;
}
export declare enum FactorType {
    /** Unknown factor type. */
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    /** Requires a password. */
    PASSWORD = "PASSWORD",
    /** Requires a code sent via SMS. */
    SMS = "SMS",
    /** Requires a code sent by phone call. */
    CALL = "CALL",
    /** Requires a code sent by email. */
    EMAIL = "EMAIL",
    /** Requires authentication via an authenticator app. */
    TOTP = "TOTP",
    /** Requires authentication via a push notification. */
    PUSH = "PUSH",
    /** Requires authentication via WebAuthn/passkey. */
    WEBAUTHN = "WEBAUTHN"
}
/** @enumType */
export type FactorTypeWithLiterals = FactorType | 'UNKNOWN_FACTOR_TYPE' | 'PASSWORD' | 'SMS' | 'CALL' | 'EMAIL' | 'TOTP' | 'PUSH' | 'WEBAUTHN';
export declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
/** @enumType */
export type StatusWithLiterals = Status | 'INACTIVE' | 'ACTIVE' | 'REQUIRE_REENROLL';
export interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
export interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
export interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
export interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
export interface RequireMfaData {
    /**
     * The factors available for the user to perform the required MFA.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required to perform MFA. */
    reason?: MfaReasonWithLiterals;
}
export interface V1Factor {
    /** Type of verification factor. */
    factorType?: FactorTypeWithLiterals;
    /** Availability status for second factor */
    factorStatus?: FactorStatusWithLiterals;
}
export declare enum FactorStatus {
    UNKNOWN_FACTOR_STATUS = "UNKNOWN_FACTOR_STATUS",
    ENABLED = "ENABLED",
    REQUIRE_ACTIVATION = "REQUIRE_ACTIVATION",
    REQUIRE_REENROLL = "REQUIRE_REENROLL",
    ENABLED_BY_RULE = "ENABLED_BY_RULE",
    DISABLED_BY_RULE = "DISABLED_BY_RULE"
}
/** @enumType */
export type FactorStatusWithLiterals = FactorStatus | 'UNKNOWN_FACTOR_STATUS' | 'ENABLED' | 'REQUIRE_ACTIVATION' | 'REQUIRE_REENROLL' | 'ENABLED_BY_RULE' | 'DISABLED_BY_RULE';
export declare enum MfaReason {
    UNKNOWN_MFA_REASON = "UNKNOWN_MFA_REASON",
    /** Mfa is required due to user settings */
    USER_SETTINGS = "USER_SETTINGS",
    /** Mfa is required due to high risk login */
    HIGH_RISK_LOGIN = "HIGH_RISK_LOGIN"
}
/** @enumType */
export type MfaReasonWithLiterals = MfaReason | 'UNKNOWN_MFA_REASON' | 'USER_SETTINGS' | 'HIGH_RISK_LOGIN';
export interface MfaChallengeData {
    /** Type of verifation factor. */
    factorType?: FactorTypeWithLiterals;
    verificationChallengeData?: VerificationChallenge;
    /**
     * Factors types the member can choose from to verify themselves.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required to perform MFA. */
    reason?: MfaReasonWithLiterals;
}
export interface VerificationChallenge extends VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
    /** @maxLength 200 */
    hint?: string | null;
}
/** @oneof */
export interface VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
}
export interface PushChallengeData {
    /**
     * This should be tied to a specific push notification.
     * It will be sent in subsequent requests to verify the factor.
     * @maxLength 36
     */
    transactionId?: string;
}
export interface WebAuthnChallengeData {
    /**
     * A unique identifier for this challenge that will be used to correlate
     * the authentication response with this challenge.
     * This should be a cryptographically random GUID to prevent guessing attacks.
     * @format GUID
     */
    challengeId?: string;
    /**
     * The challenge that will be signed by the authenticator during the WebAuthn authentication ceremony.
     * This should be a cryptographically secure random value with at least 16 bytes of entropy.
     * The value is used to prevent replay attacks and MUST be randomly generated by the implementer.
     */
    challenge?: Uint8Array;
    /**
     * The timeout in milliseconds for the WebAuthn authentication ceremony.
     * After this time, the challenge will be considered expired and the authentication will need to be restarted.
     * This is optional and may be overridden by the client if provided.
     * The WebAuthn spec recommends a timeout of at least 1 minute (60000ms).
     */
    timeoutMs?: number | null;
    /**
     * Optional list of credentials that are acceptable for this authentication ceremony.
     * If empty, all credentials associated with the user will be considered.
     * @maxSize 10
     */
    allowCredentials?: PublicKeyCredentialDescriptor[];
    /** Specifies the requirement for user verification during the authentication ceremony. */
    userVerification?: UserVerificationRequirementWithLiterals;
    /**
     * Optional hints to guide the client UI
     * Examples include "security-key" to emphasize external authenticators
     * or "client-device" to emphasize built-in authenticators
     * @maxLength 50
     * @maxSize 10
     */
    hints?: string[];
    /**
     * Optional extensions for the authentication ceremony
     * Provides additional parameters for specialized WebAuthn functionality
     */
    extensions?: AuthenticationExtensionInputs;
}
export interface PublicKeyCredentialDescriptor {
    /** The credential ID */
    _id?: Uint8Array;
    /**
     * An optional hint as to the transports used by the credential
     * Examples include "usb", "nfc", "ble", "internal", "hybrid"
     * @maxLength 50
     * @maxSize 10
     */
    transports?: string[];
}
export declare enum UserVerificationRequirement {
    /** Default unspecified value */
    USER_VERIFICATION_UNSPECIFIED = "USER_VERIFICATION_UNSPECIFIED",
    /**
     * The Relying Party requires user verification and will fail the operation if the response doesn't have the UV flag
     * set
     */
    USER_VERIFICATION_REQUIRED = "USER_VERIFICATION_REQUIRED",
    /** The Relying Party prefers user verification but will not fail the operation if unavailable */
    USER_VERIFICATION_PREFERRED = "USER_VERIFICATION_PREFERRED",
    /** The Relying Party does not want user verification employed (e.g., to minimize disruption to the user experience) */
    USER_VERIFICATION_DISCOURAGED = "USER_VERIFICATION_DISCOURAGED"
}
/** @enumType */
export type UserVerificationRequirementWithLiterals = UserVerificationRequirement | 'USER_VERIFICATION_UNSPECIFIED' | 'USER_VERIFICATION_REQUIRED' | 'USER_VERIFICATION_PREFERRED' | 'USER_VERIFICATION_DISCOURAGED';
export interface AuthenticationExtensionInputs extends AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
    /**
     * FIDO AppID Extension (appid)
     * An AppID that was used for previously registered U2F authenticators
     * This makes already-registered U2F credentials forward-compatible with the WebAuthn API
     * @maxLength 256
     */
    appid?: string;
    /**
     * User Verification Method Extension (uvm)
     * Requests the authenticator to report which verification methods were used
     * Examples include fingerprint, PIN, or facial recognition
     */
    uvm?: boolean;
}
/** @oneof */
export interface AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
}
export interface LoginV2Request {
    /** Identifier of identity logging in. */
    loginId: LoginId;
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data that's relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
export interface ChangePasswordRequest {
    /** The new password to set for the logged in user */
    newPassword: string;
}
export interface ChangePasswordResponse {
}
export interface LoginWithIdpConnectionRequest {
    /**
     * The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData
     * @format GUID
     */
    idpConnectionId?: string;
    /**
     * The id of the tenant the caller wants to login into
     * @format GUID
     */
    tenantId?: string;
    /** The type of the tenant the caller wants to login into */
    tenantType?: TenantTypeWithLiterals;
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId?: string;
    encryptionKey?: string;
    visitorId?: string | null;
    bsi?: string | null;
}
export declare enum TenantType {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
/** @enumType */
export type TenantTypeWithLiterals = TenantType | 'UNKNOWN_TENANT_TYPE' | 'ACCOUNT' | 'SITE' | 'ROOT';
export interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
export interface HeadersEntry {
    key?: string;
    value?: string;
}
export interface RawHttpRequest {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
export interface PathParametersEntry {
    key?: string;
    value?: string;
}
export interface QueryParametersEntry {
    key?: string;
    value?: string;
}
export interface LoginCallbackRequest {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
export interface LoginWithIdpConnectionTokenParamsRequest {
    /**
     * The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData)
     * @format GUID
     */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
export interface SignOnRequest {
    /** the identifier of the identity */
    loginId: LoginId;
    /** profile of the identity */
    profile?: IdentityProfile;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
export interface SignOnResponse {
    /** session token for the requested identity */
    sessionToken?: string;
    /** The Identity of the provided login_id */
    identity?: Identity;
}
/** logout request payload */
export interface LogoutRequest {
    /**
     * redirect after logout
     * @format WEB_URL
     */
    postLogoutRedirectUri?: string | null;
    /**
     * caller identifier
     * @format GUID
     */
    clientId?: string | null;
}
export interface VerifyRequest extends VerifyRequestFactorDataOneOf {
    smsData?: SmsVerifyData;
    callData?: CallVerifyData;
    emailData?: ExternalEmailVerifyData;
    totpData?: TotpVerifyData;
    pushData?: PushVerifyData;
    webauthnData?: WebAuthnVerifyData;
    /**
     * TODO: is this a reasonable maxLength?
     * @maxLength 1000
     */
    stateToken?: string;
    factorType: FactorTypeWithLiterals;
    rememberThisDevice?: boolean;
}
/** @oneof */
export interface VerifyRequestFactorDataOneOf {
    smsData?: SmsVerifyData;
    callData?: CallVerifyData;
    emailData?: ExternalEmailVerifyData;
    totpData?: TotpVerifyData;
    pushData?: PushVerifyData;
    webauthnData?: WebAuthnVerifyData;
}
export interface SmsVerifyData {
    /**
     * @minLength 1
     * @maxLength 100
     */
    code?: string | null;
}
export interface CallVerifyData {
    /**
     * @minLength 1
     * @maxLength 100
     */
    code?: string | null;
}
export interface ExternalEmailVerifyData {
    /**
     * @minLength 1
     * @maxLength 100
     */
    code?: string | null;
}
export interface TotpVerifyData {
    /**
     * @minLength 1
     * @maxLength 100
     */
    code?: string | null;
}
export interface PushVerifyData {
    /** @maxLength 36 */
    transactionId?: string | null;
}
export interface WebAuthnVerifyData {
    /**
     * The challenge_id from the WebAuthnChallengeData that was returned in the previous
     * verification response. This will always be present when completing the WebAuthn authentication
     * ceremony with the credential data from the client.
     * @format GUID
     */
    challengeId?: string | null;
    /**
     * If this field is present, this is a request to complete the WebAuthn authentication
     * with the credential data from the client.
     *
     * The credential contains a JSON string representation of a WebAuthn PublicKeyCredential
     * object returned by the browser during authentication, serialized as per the WebAuthn specification.
     * The SPI implementation should use this to verify the authentication assertion.
     *
     * Any standards-compliant WebAuthn server library should be able to process this serialized format.
     * For details on the serialization format, refer to the W3C WebAuthn specification:
     * https://www.w3.org/TR/webauthn-3/#dom-publickeycredential-tojson
     * @maxLength 3000
     */
    credential?: string | null;
}
/**
 * Registers a new member.
 *
 * Typically, after a successful registration, you generate and use member tokens for the
 * registered member so that subsequent API calls are called as part of a member session.
 * Use the `sessionToken` in the response to [get the site member's access and refresh tokens](https://dev.wix.com/docs/go-headless/coding/rest-api/visitors-and-members/handle-members-with-custom-login#get-the-site-members-access-and-refresh-tokens).
 *
 * If the email used to register the member already exists as a contact email, the registering
 * member need to verify the email address using a code that is sent to the address.
 * @param loginId - Identifier of the registering member.
 * @public
 * @requiredField loginId
 * @fqn wix.iam.authentication.v1.AuthenticationService.RegisterV2
 */
export declare function registerV2(loginId: LoginId, options?: RegisterV2Options): Promise<NonNullablePaths<StateMachineResponse, `state` | `identity.connections` | `identity.connections.${number}.idpConnection.idpConnectionId` | `identity.connections.${number}.idpConnection.idpUserId` | `identity.connections.${number}.authenticatorConnection.authenticatorConnectionId` | `identity.connections.${number}.authenticatorConnection.reEnrollmentRequired` | `identity.identityProfile.emails` | `identity.identityProfile.phones` | `identity.identityProfile.labels` | `identity.identityProfile.privacyStatus` | `identity.identityProfile.customFields` | `identity.identityProfile.customFields.${number}.name` | `identity.identityProfile.customFields.${number}.value.strValue` | `identity.identityProfile.customFields.${number}.value.numValue` | `identity.identityProfile.secondaryEmails` | `identity.identityProfile.secondaryEmails.${number}.email` | `identity.identityProfile.secondaryEmails.${number}.tag` | `identity.identityProfile.phonesV2` | `identity.identityProfile.phonesV2.${number}.phone` | `identity.identityProfile.phonesV2.${number}.tag` | `identity.identityProfile.addresses` | `identity.identityProfile.addresses.${number}.tag` | `identity.metadata.tags` | `identity.email.address` | `identity.email.isVerified` | `identity.status.name` | `identity.status.reasons` | `identity.factors` | `identity.factors.${number}.factorId` | `identity.factors.${number}.type` | `identity.factors.${number}.status`>>;
export interface RegisterV2Options {
    /** Password of the registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data that's relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
/**
 * Logs in an existing member.
 *
 * Typically, after a successful login, you generate and use member tokens for the
 * logged-in member so that subsequent API calls are called as part of a member session.
 * Use the `sessionToken` in the response to [get the site member's access and refresh tokens](https://dev.wix.com/docs/go-headless/coding/rest-api/visitors-and-members/handle-members-with-custom-login#get-the-site-members-access-and-refresh-tokens).
 * @param loginId - Identifier of identity logging in.
 * @public
 * @requiredField loginId
 * @fqn wix.iam.authentication.v1.AuthenticationService.LoginV2
 */
export declare function loginV2(loginId: LoginId, options?: LoginV2Options): Promise<NonNullablePaths<StateMachineResponse, `state` | `identity.connections` | `identity.connections.${number}.idpConnection.idpConnectionId` | `identity.connections.${number}.idpConnection.idpUserId` | `identity.connections.${number}.authenticatorConnection.authenticatorConnectionId` | `identity.connections.${number}.authenticatorConnection.reEnrollmentRequired` | `identity.identityProfile.emails` | `identity.identityProfile.phones` | `identity.identityProfile.labels` | `identity.identityProfile.privacyStatus` | `identity.identityProfile.customFields` | `identity.identityProfile.customFields.${number}.name` | `identity.identityProfile.customFields.${number}.value.strValue` | `identity.identityProfile.customFields.${number}.value.numValue` | `identity.identityProfile.secondaryEmails` | `identity.identityProfile.secondaryEmails.${number}.email` | `identity.identityProfile.secondaryEmails.${number}.tag` | `identity.identityProfile.phonesV2` | `identity.identityProfile.phonesV2.${number}.phone` | `identity.identityProfile.phonesV2.${number}.tag` | `identity.identityProfile.addresses` | `identity.identityProfile.addresses.${number}.tag` | `identity.metadata.tags` | `identity.email.address` | `identity.email.isVerified` | `identity.status.name` | `identity.status.reasons` | `identity.factors` | `identity.factors.${number}.factorId` | `identity.factors.${number}.type` | `identity.factors.${number}.status`>>;
export interface LoginV2Options {
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data that's relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
/**
 * Changes the password of a logged in user.
 * @param newPassword - The new password to set for the logged in user
 * @public
 * @documentationMaturity preview
 * @requiredField newPassword
 * @permissionId IAM.CHANGE_PASSWORD
 * @fqn wix.iam.authentication.v1.AuthenticationService.ChangePassword
 */
export declare function changePassword(newPassword: string): Promise<void>;
/** @public
 * @documentationMaturity preview
 * @fqn wix.iam.authentication.v1.AuthenticationService.LoginCallback
 */
export declare function loginCallback(options?: LoginCallbackOptions): Promise<NonNullablePaths<RawHttpResponse, `body` | `headers` | `headers.${number}.key` | `headers.${number}.value`>>;
export interface LoginCallbackOptions {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
/** @param loginId - the identifier of the identity
 * @public
 * @documentationMaturity preview
 * @requiredField loginId
 * @permissionId IAM.AUTHENTICAITON_SIGN_ON
 * @permissionScope Manage Members Authentication
 * @permissionScopeId SCOPE.DC-IDENTITY.MANAGE_AUTHENTICATION
 * @applicableIdentity APP
 * @fqn wix.iam.authentication.v1.AuthenticationService.SignOn
 */
export declare function signOn(loginId: LoginId, options?: SignOnOptions): Promise<NonNullablePaths<SignOnResponse, `sessionToken` | `identity.connections` | `identity.connections.${number}.idpConnection.idpConnectionId` | `identity.connections.${number}.idpConnection.idpUserId` | `identity.connections.${number}.authenticatorConnection.authenticatorConnectionId` | `identity.connections.${number}.authenticatorConnection.reEnrollmentRequired` | `identity.identityProfile.emails` | `identity.identityProfile.phones` | `identity.identityProfile.labels` | `identity.identityProfile.privacyStatus` | `identity.identityProfile.customFields` | `identity.identityProfile.customFields.${number}.name` | `identity.identityProfile.customFields.${number}.value.strValue` | `identity.identityProfile.customFields.${number}.value.numValue` | `identity.identityProfile.secondaryEmails` | `identity.identityProfile.secondaryEmails.${number}.email` | `identity.identityProfile.secondaryEmails.${number}.tag` | `identity.identityProfile.phonesV2` | `identity.identityProfile.phonesV2.${number}.phone` | `identity.identityProfile.phonesV2.${number}.tag` | `identity.identityProfile.addresses` | `identity.identityProfile.addresses.${number}.tag` | `identity.metadata.tags` | `identity.email.address` | `identity.email.isVerified` | `identity.status.name` | `identity.status.reasons` | `identity.factors` | `identity.factors.${number}.factorId` | `identity.factors.${number}.type` | `identity.factors.${number}.status`>>;
export interface SignOnOptions {
    /** profile of the identity */
    profile?: IdentityProfile;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
/**
 * Logs out a member.
 * @public
 * @documentationMaturity preview
 * @fqn wix.iam.authentication.v1.AuthenticationService.Logout
 */
export declare function logout(options?: LogoutOptions): Promise<NonNullablePaths<RawHttpResponse, `body` | `headers` | `headers.${number}.key` | `headers.${number}.value`>>;
export interface LogoutOptions {
    /**
     * redirect after logout
     * @format WEB_URL
     */
    postLogoutRedirectUri?: string | null;
    /**
     * caller identifier
     * @format GUID
     */
    clientId?: string | null;
}
/** @public
 * @documentationMaturity preview
 * @requiredField factorType
 * @fqn wix.iam.authentication.v1.AuthenticationService.Verify
 */
export declare function verify(factorType: FactorTypeWithLiterals, options?: VerifyOptions): Promise<NonNullablePaths<StateMachineResponse, `state` | `identity.connections` | `identity.connections.${number}.idpConnection.idpConnectionId` | `identity.connections.${number}.idpConnection.idpUserId` | `identity.connections.${number}.authenticatorConnection.authenticatorConnectionId` | `identity.connections.${number}.authenticatorConnection.reEnrollmentRequired` | `identity.identityProfile.emails` | `identity.identityProfile.phones` | `identity.identityProfile.labels` | `identity.identityProfile.privacyStatus` | `identity.identityProfile.customFields` | `identity.identityProfile.customFields.${number}.name` | `identity.identityProfile.customFields.${number}.value.strValue` | `identity.identityProfile.customFields.${number}.value.numValue` | `identity.identityProfile.secondaryEmails` | `identity.identityProfile.secondaryEmails.${number}.email` | `identity.identityProfile.secondaryEmails.${number}.tag` | `identity.identityProfile.phonesV2` | `identity.identityProfile.phonesV2.${number}.phone` | `identity.identityProfile.phonesV2.${number}.tag` | `identity.identityProfile.addresses` | `identity.identityProfile.addresses.${number}.tag` | `identity.metadata.tags` | `identity.email.address` | `identity.email.isVerified` | `identity.status.name` | `identity.status.reasons` | `identity.factors` | `identity.factors.${number}.factorId` | `identity.factors.${number}.type` | `identity.factors.${number}.status`>>;
export interface VerifyOptions extends VerifyOptionsFactorDataOneOf {
    /**
     * TODO: is this a reasonable maxLength?
     * @maxLength 1000
     */
    stateToken?: string;
    rememberThisDevice?: boolean;
    smsData?: SmsVerifyData;
    callData?: CallVerifyData;
    emailData?: ExternalEmailVerifyData;
    totpData?: TotpVerifyData;
    pushData?: PushVerifyData;
    webauthnData?: WebAuthnVerifyData;
}
/** @oneof */
export interface VerifyOptionsFactorDataOneOf {
    smsData?: SmsVerifyData;
    callData?: CallVerifyData;
    emailData?: ExternalEmailVerifyData;
    totpData?: TotpVerifyData;
    pushData?: PushVerifyData;
    webauthnData?: WebAuthnVerifyData;
}
