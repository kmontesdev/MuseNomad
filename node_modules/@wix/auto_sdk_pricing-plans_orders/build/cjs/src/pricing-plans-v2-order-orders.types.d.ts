/**
 * An order object includes all of the details related to the purchase of a Pricing Plan.
 * You can manage existing orders, create offline orders, and preview orders not yet purchased.
 *
 * Orders are based on pricing models based on the payment and duration cycles for each plan.
 * Learn more about pricing models ([REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models)|[SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/introduction#pricing-models)).
 */
export interface Order {
    /**
     * Order ID.
     * @format GUID
     * @readonly
     */
    id?: string;
    /**
     * ID of the plan purchased with the order, from the Plans API.
     * @format GUID
     * @readonly
     */
    planId?: string;
    /**
     * ID of the related Wix subscription.
     *
     * Every pricing plan order corresponds to a Wix subscription, including orders for single payment plans. Learn more in
     * a [Pricing Plans overview](https://support.wix.com/en/article/pricing-plans-an-overview#create-plans-to-suit-your-business).
     * @format GUID
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Wix Pay order ID.
     *
     * Provided by Wix whether the order is created online or offline. The field is omitted when the order is free.
     * @format GUID
     * @readonly
     */
    wixPayOrderId?: string | null;
    /**
     * The buyer's IDs. Includes `memberId` and `contactId`.
     *
     * Currently, Pricing Plan purchases are limited to members only. `contactId` is returned,
     * but a buyer will not be able to purchase a plan without a `memberId`.
     * @readonly
     */
    buyer?: Buyer;
    /**
     * __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @readonly
     * @deprecated __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @replacedBy pricing
     * @targetRemovalDate 2022-10-01
     */
    priceDetails?: PriceDetails;
    /**
     * Order pricing model, price, and payment schedule.
     *
     * Learn more about pricing models ([REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models) | [SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/introduction#pricing-models)).
     * @readonly
     */
    pricing?: PricingDetails;
    /**
     * How the order was processed.
     * @readonly
     */
    type?: OrderTypeWithLiterals;
    /**
     * Status of the order.
     * @readonly
     */
    status?: OrderStatusWithLiterals;
    /**
     * Whether the order will be canceled at the next payment date.
     *
     * If `true`, the order status will be `CANCELED` and the next payment won't be charged. Omitted for single payment orders.
     * @readonly
     */
    autoRenewCanceled?: boolean | null;
    /**
     * Details about the cancellation of an order.
     *
     * Only present if the status is `CANCELED`.
     * @readonly
     */
    cancellation?: Cancellation;
    /**
     * Status of the last payment for the order.
     * Updated automatically for online orders. Updated manually by the Wix user for offline orders.
     * @readonly
     */
    lastPaymentStatus?: PaymentStatusWithLiterals;
    /**
     * Start date and time for the ordered plan.
     * @readonly
     */
    startDate?: Date | null;
    /**
     * Current end date and time for the ordered plan.
     *
     * `endDate` may be updated over the course of an order.
     * If the order is paused, it will have a later `endDate` once it is resumed.
     * `endDate` may also be postponed.
     *
     * Omitted if the order is valid until canceled and still `ACTIVE`.
     * @readonly
     */
    endDate?: Date | null;
    /**
     * List of periods during which the order is paused.
     * @readonly
     */
    pausePeriods?: PausePeriod[];
    /**
     * Free trial period for the order, in days.
     *
     * Only available for recurring plans.
     * @readonly
     * @min 1
     * @max 999
     */
    freeTrialDays?: number | null;
    /**
     * Earliest end date and time that the plan for the order can expire.
     *
     * Calculated by using the original end date plus any pause periods. Omitted if the order is active until canceled. Reserved for future use.
     * @readonly
     */
    earliestEndDate?: Date | null;
    /**
     * Current payment cycle for the order.
     *
     * `currentCycle` will be omitted if the order's status is `CANCELED` or `ENDED`, or if the `startDate` hasn't passed yet.
     * @readonly
     */
    currentCycle?: CurrentCycle;
    /**
     * Plan name at the time of purchase.
     * @readonly
     */
    planName?: string;
    /**
     * Plan description at the time of purchase
     * @readonly
     */
    planDescription?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @format DECIMAL_VALUE
     * @readonly
     */
    planPrice?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Information about the form submitted during the plan's checkout.
     * @readonly
     */
    formData?: FormData;
}
export interface Buyer {
    /**
     * Member ID for a Wix site member, from the Members API.
     * @format GUID
     * @readonly
     */
    memberId?: string;
    /**
     * Contact ID for a Wix site contact, from the Contacts API.
     * @format GUID
     * @readonly
     */
    contactId?: string;
}
export interface PriceDetails extends PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Price of the order excluding tax, specified as a monetary amount. for example, `"9.99"`.
     * @format DECIMAL_VALUE
     */
    subtotal?: string;
    /**
     * Total discount applied.
     * @format DECIMAL_VALUE
     */
    discount?: string;
    /** Tax applied. */
    tax?: Tax;
    /**
     * Price after tax and discount is applied, specified as a monetary amount. For example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     * @format DECIMAL_VALUE
     */
    total?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @format DECIMAL_VALUE
     */
    planPrice?: string;
    /**
     * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Free trial period for the order in days. Only available for recurring plans.
     * @min 1
     * @max 999
     */
    freeTrialDays?: number | null;
    /** Coupon applied to the order. Empty means no coupon was applied. */
    coupon?: Coupon;
}
/** @oneof */
export interface PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
export interface Tax {
    /** Name of the tax. For example, VAT. */
    name?: string;
    /** Whether tax is included in the original price. When `false`, tax is added at checkout. */
    includedInPrice?: boolean;
    /**
     * Tax rate percentage, as a number between 0 and 100. For example, a 7% tax rate is `"7.00"`.
     * @format DECIMAL_VALUE
     */
    rate?: string;
    /**
     * Total tax, specified as a monetary amount. For example, `"3.99"`.
     * @format DECIMAL_VALUE
     */
    amount?: string;
}
/** An object specifying how often and for how long payments recur (may be forever). */
export interface Recurrence {
    /**
     * Number of payment cycles the subscription is valid for.
     * `0` for unlimited plans or for plans that are valid until canceled.
     */
    cycleDuration?: Duration;
    /**
     * Length of a payment cycle. For example, 1 month to have monthly payments.
     * Multiply `cycleDuration`'s `count` by `cycleCount` to get the subscription duration.
     * Currently, only a value of `1` is supported.
     * @max 2000
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
export interface Duration {
    /**
     * Number of days, months, weeks, or years in a single payment cycle. Currently limited to support only `1`.
     * @min 1
     */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnitWithLiterals;
}
export declare enum PeriodUnit {
    /** Not defined. */
    UNDEFINED = "UNDEFINED",
    /** Time unit is a day. */
    DAY = "DAY",
    /** Time unit is a week. */
    WEEK = "WEEK",
    /** Time unit is a month. */
    MONTH = "MONTH",
    /** Time unit is a year. */
    YEAR = "YEAR"
}
/** @enumType */
export type PeriodUnitWithLiterals = PeriodUnit | 'UNDEFINED' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
export interface Coupon {
    /**
     * Code of the applied coupon.
     * @minLength 1
     * @maxLength 20
     */
    code?: string;
    /**
     * Total discount of the coupon, as a monetary amount.
     * @format DECIMAL_VALUE
     */
    amount?: string;
    /**
     * Coupon ID.
     * @format GUID
     * @readonly
     */
    id?: string;
}
export interface PricingDetails extends PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Pricing details for all pricing models.
     * @readonly
     */
    prices?: SpannedPrice[];
}
/** @oneof */
export interface PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
export interface SpannedPrice {
    /**
     * Cycle duration to apply `price` for.
     *
     * Use with all pricing models.
     * Can apply the same price to multiple payment cycles.
     */
    duration?: PriceDuration;
    /** Order price. */
    price?: Price;
}
export interface PriceDuration {
    /**
     * Price starts to apply with this cycle.
     *
     * `1` is the first payment cycle for all pricing models.
     */
    cycleFrom?: number;
    /**
     * Amount of cycles to apply price for.
     *
     * For `subscription` pricing models with a finite number of cycles, the `numberOfCycles` is the same as `pricing.subscription.cycleCount`.
     *
     * For `subscription` pricing models that are unlimited or until-canceled, the `numberOfCycles` is not returned.
     *
     * For `singlePaymentForDuration` and `singlePaymentUnlimited` pricing models, the `numberOfCycles` is `1`.
     */
    numberOfCycles?: number | null;
}
export interface Price {
    /**
     * Price of the order excluding tax, specified as a monetary amount. For example, `"9.99"`.
     * @format DECIMAL_VALUE
     */
    subtotal?: string;
    /** Coupon applied to the order, from the Coupons API. */
    coupon?: Coupon;
    /**
     * Total discount applied to the order.
     * @format DECIMAL_VALUE
     */
    discount?: string;
    /**
     * Tax applied to the order.
     *
     * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
     */
    tax?: Tax;
    /**
     * Price after tax and discount is applied. Specified as a monetary amount, for example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     * @format DECIMAL_VALUE
     */
    total?: string;
    /**
     * Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Price change after billing date was change and price was adjusted. Could be positive and negative values.
     * @format DECIMAL_VALUE
     */
    proration?: string;
}
export interface Fee {
    /**
     * Fee name
     * @minLength 1
     * @maxLength 40
     */
    name?: string;
    /**
     * Amount of fee to be charged
     * @decimalValue options { lt:1000000000000, gt:0.000, maxScale:3 }
     */
    amount?: string;
}
export declare enum OrderType {
    /** Undefined order type. */
    UNDEFINED = "UNDEFINED",
    /** The buyer purchased the plan using the site. */
    ONLINE = "ONLINE",
    /** The buyer made a manual, offline purchase without using the site. */
    OFFLINE = "OFFLINE",
    /** The buyer made a purchase through an external payment provider. */
    EXTERNAL = "EXTERNAL"
}
/** @enumType */
export type OrderTypeWithLiterals = OrderType | 'UNDEFINED' | 'ONLINE' | 'OFFLINE' | 'EXTERNAL';
export declare enum OrderMethod {
    /** Unknown order method. */
    UNKNOWN = "UNKNOWN",
    /** Mail Order / Telephone Order transaction. */
    MOTO = "MOTO",
    /** Point of Sale transaction. */
    POS = "POS"
}
/** @enumType */
export type OrderMethodWithLiterals = OrderMethod | 'UNKNOWN' | 'MOTO' | 'POS';
export declare enum OrderStatus {
    /** Undefined order status. */
    UNDEFINED = "UNDEFINED",
    /** Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer. */
    DRAFT = "DRAFT",
    /** Order has been purchased and its start date is set in the future. */
    PENDING = "PENDING",
    /** Order has been processed. The plan is available for use. */
    ACTIVE = "ACTIVE",
    /** Order, and use of the plan, is paused. The order, and use of the plan, can be resumed. */
    PAUSED = "PAUSED",
    /** Order has completed its duration and is no longer available for use. */
    ENDED = "ENDED",
    /** Order has been canceled. */
    CANCELED = "CANCELED"
}
/** @enumType */
export type OrderStatusWithLiterals = OrderStatus | 'UNDEFINED' | 'DRAFT' | 'PENDING' | 'ACTIVE' | 'PAUSED' | 'ENDED' | 'CANCELED';
export interface Cancellation {
    /** Date and time the cancellation was requested. */
    requestedDate?: Date | null;
    /** Reason for the cancellation. */
    cause?: CancellationCauseWithLiterals;
    /** When the cancellation takes effect. Set when cancelling the order. */
    effectiveAt?: CancellationEffectiveAtWithLiterals;
}
export declare enum CancellationCause {
    /** Undefined cancellation cause. */
    UNDEFINED = "UNDEFINED",
    /** Wix user canceled the order. */
    OWNER_ACTION = "OWNER_ACTION",
    /** Buyer initiated the cancellation. */
    MEMBER_ACTION = "MEMBER_ACTION",
    /** Payment transaction failed. */
    PAYMENT_FAILURE = "PAYMENT_FAILURE",
    /** Buyer's payment details weren't set up correctly. */
    PAYMENT_SETUP_FAILURE = "PAYMENT_SETUP_FAILURE",
    /** Reason for the cancellation is unknown. */
    UNKNOWN = "UNKNOWN"
}
/** @enumType */
export type CancellationCauseWithLiterals = CancellationCause | 'UNDEFINED' | 'OWNER_ACTION' | 'MEMBER_ACTION' | 'PAYMENT_FAILURE' | 'PAYMENT_SETUP_FAILURE' | 'UNKNOWN';
export declare enum CancellationEffectiveAt {
    /** Undefined cancellation time. */
    UNDEFINED = "UNDEFINED",
    /** Cancellation occurs immediately and the buyer can no longer use the plan. */
    IMMEDIATELY = "IMMEDIATELY",
    /** Cancellation occurs at the next payment date and time. Buyer can continue to use the plan until that date and time. */
    NEXT_PAYMENT_DATE = "NEXT_PAYMENT_DATE"
}
/** @enumType */
export type CancellationEffectiveAtWithLiterals = CancellationEffectiveAt | 'UNDEFINED' | 'IMMEDIATELY' | 'NEXT_PAYMENT_DATE';
export declare enum PaymentStatus {
    /** Undefined payment status. */
    UNDEFINED = "UNDEFINED",
    /** Payment has been paid. */
    PAID = "PAID",
    /** Payment has been refunded. */
    REFUNDED = "REFUNDED",
    /** Payment transaction didn't complete. */
    FAILED = "FAILED",
    /** Payment has not been paid. */
    UNPAID = "UNPAID",
    /** Billing has been initialized, but actual charge is yet to be made. This can happen for free trials and payments made with PayPal. */
    PENDING = "PENDING",
    /** No payment was necessary. For example, for free plans or free trials. */
    NOT_APPLICABLE = "NOT_APPLICABLE"
}
/** @enumType */
export type PaymentStatusWithLiterals = PaymentStatus | 'UNDEFINED' | 'PAID' | 'REFUNDED' | 'FAILED' | 'UNPAID' | 'PENDING' | 'NOT_APPLICABLE';
export interface PausePeriod {
    /** Status of the pause period. */
    status?: StatusWithLiterals;
    /** Start date and time of the pause period. */
    pauseDate?: Date | null;
    /**
     * End date and time of the pause period.
     *
     * Omitted while the pause period remains `ACTIVE`.
     */
    resumeDate?: Date | null;
}
export declare enum Status {
    /** Undefined status. */
    UNDEFINED = "UNDEFINED",
    /** Status while the order is paused. */
    ACTIVE = "ACTIVE",
    /** Status when the order is resumed. */
    ENDED = "ENDED"
}
/** @enumType */
export type StatusWithLiterals = Status | 'UNDEFINED' | 'ACTIVE' | 'ENDED';
/**
 * Current cycle will be empty when order is cancelled, expired or order start date is in the future
 * Current cycle start and end dates take into account free trial days and suspensions
 */
export interface CurrentCycle {
    /**
     * Index of the current payment cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for the current payment cycle. */
    startedDate?: Date | null;
    /** End date and time for the current payment cycle. */
    endedDate?: Date | null;
}
/** Order cycle start and end dates take into account free trial days and suspensions */
export interface OrderCycle {
    /**
     * Index of this cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for this order cycle. */
    startedDate?: Date | null;
    /** End date and time for this order cycle. */
    endedDate?: Date | null;
}
export interface FormData {
    /**
     * ID of the order form ([REST](https://dev.wix.com/docs/rest/api-reference/wix-forms/form-submissions/introduction)|[SDK](https://dev.wix.com/docs/sdk/backend-modules/forms/submissions/introduction)) associated with the plan at checkout.
     * @format GUID
     */
    formId?: string | null;
    /**
     * ID of a submission to the plan's order form at checkout. Every time a visitor completes the checkout process for a plan, a new submission is created.
     * @format GUID
     */
    submissionId?: string | null;
    /**
     * Data submitted to the plan's order form at checkout.
     * @readonly
     */
    submissionData?: Record<string, any>;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
export interface ActionEvent {
    bodyAsJson?: string;
}
export interface Empty {
}
export interface OrderPurchased {
    /** Order that was paid for. If a free or an offline order, the order that was created. */
    order?: Order;
}
export interface OrderStarted {
    /** Order that reached its `startDate`. */
    order?: Order;
}
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook does not trigger at the initial start of an offline order.
 */
export interface OrderCycleStarted {
    /** Order whose new cycle started. */
    order?: Order;
    /** Number of the payment cycle will be 0 when the order is in the free trial period. In other cases, the cycle number starts from 1. */
    cycleNumber?: number;
}
/** Emitted when a recurring order is canceled for the next payment cycle */
export interface OrderAutoRenewCanceled {
    /** Order that is canceled, effective at the end of the current payment cycle. */
    order?: Order;
}
export interface OrderEnded {
    /** Order that ended. */
    order?: Order;
}
export interface GetOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id: string;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
export declare enum Set {
    /** Same behavior as `BASIC`.` */
    UNKNOWN_SET = "UNKNOWN_SET",
    /** Doesn't return any order form submission data. */
    BASIC = "BASIC",
    /** Returns all order form submission data. */
    FULL = "FULL"
}
/** @enumType */
export type SetWithLiterals = Set | 'UNKNOWN_SET' | 'BASIC' | 'FULL';
export interface GetOrderResponse {
    /** Order. */
    order?: Order;
}
export interface ListOrdersRequest {
    /**
     * Filter by a buyer's member ID, from the Members API.
     * @format GUID
     */
    buyerIds?: string[];
    /**
     * Filter by plan IDs, from the Plans API.
     * @format GUID
     */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatusWithLiterals[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatusWithLiterals[];
    /**
     * Number of orders to return. See Sorting and Paging for more information.
     *
     * Max: `50`
     * @min 1
     * @max 50
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`.
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
export interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
export type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
export interface ListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
export interface OrdersQueryOrdersRequest {
    /** Query filter. */
    query?: QueryV2;
}
export interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
export interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
export interface OrdersQueryOrdersResponse {
    /** Retrieved orders. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface GetOrdersStatsRequest {
}
export interface GetOrdersStatsResponse {
    /** Total number of orders. */
    totalOrderCount?: number;
    /** Number of active orders. */
    activeOrderCount?: number;
}
export interface GetAvailableOrderActionsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id?: string;
}
export interface GetAvailableOrderActionsResponse {
    /** Whether the order can be suspended. */
    suspendable?: boolean;
    /** If the order cannot be suspended, a reason is returned here. */
    notSuspendableReason?: ReasonNotSuspendableWithLiterals;
    /** Whether the order can be canceled by the buyer. */
    cancelableByBuyer?: boolean;
}
export declare enum ReasonNotSuspendable {
    /** Undefined reason. */
    UNDEFINED = "UNDEFINED",
    /** Saved in the database but is awaiting payment. Non-active orders can't be suspended. */
    PENDING = "PENDING",
    /** Trial orders can't be suspended. */
    TRIAL = "TRIAL",
    /** Canceled orders can't be suspended. */
    CANCELED = "CANCELED",
    /** Ended orders can't be suspended. */
    ENDED = "ENDED",
    /** Paid for orders with future start dates can't be suspended. */
    NOT_STARTED = "NOT_STARTED",
    /** Order is already suspended. */
    ALREADY_SUSPENDED = "ALREADY_SUSPENDED",
    /** Orders based on recurring payments using older stripe versions can't be suspended. */
    OLD_STRIPE = "OLD_STRIPE"
}
/** @enumType */
export type ReasonNotSuspendableWithLiterals = ReasonNotSuspendable | 'UNDEFINED' | 'PENDING' | 'TRIAL' | 'CANCELED' | 'ENDED' | 'NOT_STARTED' | 'ALREADY_SUSPENDED' | 'OLD_STRIPE';
export interface PostponeEndDateRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id: string;
    /**
     * New end date and time.
     *
     * Must be later than the current end date and time.
     */
    endDate: Date | null;
}
export interface PostponeEndDateResponse {
}
export interface OrderEndDatePostponed {
    /** Order whose `endDate` was postponed. */
    order?: Order;
}
export interface CancelOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id: string;
    /** __Required.__ When the order will be canceled. One-time orders can only be canceled `IMMEDIATELY`. */
    effectiveAt: CancellationEffectiveAtWithLiterals;
}
export interface CancelOrderResponse {
}
/**
 * Emitted when an order is canceled immediately or when cycle ends for an order with canceled auto renewal
 *
 * To determine the specific reason of the cancellation check `order.cancellation.cause` field.
 */
export interface OrderCanceled {
    /** Canceled order. */
    order?: Order;
}
export interface MarkAsPaidRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id: string;
}
export interface MarkAsPaidResponse {
}
export interface OrderMarkedAsPaid {
    /** Order that was marked as paid. */
    order?: Order;
}
export interface PauseOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id: string;
}
export interface PauseOrderResponse {
}
export interface OrderPaused {
    /** Paused order. */
    order?: Order;
}
export interface BulkPauseOrderRequest {
    /**
     * List of Order IDs.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
export interface BulkPauseOrderResponse {
    /** Orders that were paused. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkOrderResult {
    /** Item metadata */
    itemMetadata?: ItemMetadata;
    /** The order. */
    order?: Order;
}
export interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
export interface ResumeOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id: string;
}
export interface ResumeOrderResponse {
}
export interface OrderResumed {
    /** Resumed order. */
    order?: Order;
}
export interface BulkResumeOrderRequest {
    /**
     * List of Order IDs.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
export interface BulkResumeOrderResponse {
    /** Orders that were resumed. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
export type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
export interface MemberGetOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id: string;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
export interface MemberGetOrderResponse {
    /** Requested order. */
    order?: Order;
}
export interface MemberListOrdersRequest {
    /**
     * Filter by plan IDs.
     * @format GUID
     */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatusWithLiterals[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatusWithLiterals[];
    /**
     * Limit the number of pricing plans returned. Default limit is 50.
     * @min 1
     * @max 50
     */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
export interface MemberListOrdersResponse {
    /** Requested orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
/**
 * TODO: Write orders filter and sort docs page
 * Retrieves a list of up to 1,000 orders, based on the provided paging, sorting, and filtering.
 */
export interface QueryOrdersRequest {
    /** Query filter. */
    query?: QueryV2;
}
export interface QueryOrdersResponse {
    /** Order data. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface RequestCancellationRequest {
    /**
     * Order ID.
     * @format GUID
     */
    id: string;
    /** Required. Whether to cancel the order effective immediately or at the next payment date. One-time orders can only be canceled immediately. */
    effectiveAt: CancellationEffectiveAtWithLiterals;
}
export interface RequestCancellationResponse {
}
export interface CreateOnlineOrderRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId: string;
    /**
     * Start date and time for the plan of the online order in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /** Provided if checkout is initiated on buyer's behalf. */
    onBehalf?: OnBehalf;
    /**
     * Submission ID of the form submitted with this order.
     * @format GUID
     */
    submissionId?: string | null;
}
export interface OnBehalf {
    /**
     * Member ID.
     * @format GUID
     */
    memberId?: string;
    /** Method by which checkout is initiated. */
    orderMethod?: OrderMethodWithLiterals;
}
export interface CreateOnlineOrderResponse {
    /** Created online order. */
    order?: Order;
}
export interface CouponsError {
    /** Coupon code. */
    couponCode?: string;
    /** Plan ID. */
    planId?: string;
}
export interface CreateGuestOnlineOrderRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /** Captcha data to prove you are not a robot */
    captcha?: Captcha;
    /** Visitor info */
    guest?: Guest;
    /**
     * Form submission id that was submitted together with the order
     * @format GUID
     */
    submissionId?: string | null;
}
export interface Captcha {
    /** Token from captcha */
    token?: string;
}
export interface Guest {
    /**
     * Email for checkout
     * @format EMAIL
     */
    email?: string;
}
export interface CreateGuestOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
export interface CreateOfflineOrderRequest {
    /**
     * ID of the plan being ordered, from the Plans API.
     * @format GUID
     */
    planId: string;
    /**
     * ID of the member ordering the plan, from the Members API.
     * @format GUID
     */
    memberId: string;
    /**
     * Start date and time for the ordered plan in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /**
     * Form submission ID that was submitted with the order.
     * @format GUID
     */
    submissionId?: string | null;
}
export interface CreateOfflineOrderResponse {
    /** Order. */
    order?: Order;
}
export interface CreateExternalOrderRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId?: string;
    /**
     * Form submission id that was submitted together with the order
     * @format GUID
     */
    submissionId?: string | null;
}
export interface CreateExternalOrderResponse {
    /** Created order */
    order?: Order;
}
export interface GetOnlineOrderPreviewRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId: string;
    /**
     * Start date and time for the plan of the order preview in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
export interface GetOnlineOrderPreviewResponse {
    /** Order preview. This field is undefined if the member has already reached the purchase limit for the order's plan. */
    order?: Order;
    /** Whether the member has already reached purchase limit for the order's plan. */
    purchaseLimitExceeded?: boolean;
}
export interface GetGuestOnlineOrderPreviewRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /**
     * Email for checkout
     * @format EMAIL
     */
    email?: string;
}
export interface GetGuestOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this email.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
export interface GetOfflineOrderPreviewRequest {
    /**
     * ID of the plan of the previewed order, from the Plans API.
     * @format GUID
     */
    planId: string;
    /**
     * Member ID of the buyer the previewed order is for, from the Members API.
     * @format GUID
     */
    memberId: string;
    /**
     * Start date and time for plan of the previewed order in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
export interface GetOfflineOrderPreviewResponse {
    /** The previewed order, as if the plan had been ordered. */
    order?: Order;
    /**
     * Whether this previewed order would exceed the permitted amount of purchases available
     * for this plan for this buyer.
     *
     * Always `false` for plans that do not have purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
export interface GetPricePreviewRequest {
    /**
     * ID of plan to preview.
     * @format GUID
     */
    planId: string;
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
export interface GetPricePreviewResponse {
    /**
     * __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @deprecated __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @replacedBy prices
     * @targetRemovalDate 2022-10-01
     */
    price?: PriceDetails;
    /** Pricing details. */
    prices?: SpannedPrice[];
}
export interface ChangeStartDateRequest {
    /**
     * Draft order ID.
     * @format GUID
     */
    orderId?: string;
    /** New valid from date (timestamp). */
    startDate?: Date | null;
}
export interface ChangeStartDateResponse {
    /** Updated draft order. */
    order?: Order;
}
export interface OrderStartDateChanged {
    /** Order whose `startDate` changed. */
    order?: Order;
}
export interface ApplyCouponRequest {
    /**
     * Draft order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string;
}
export interface ApplyCouponResponse {
    /** Order with applied coupon and recalculated tax. */
    order?: Order;
}
export interface SetSubmissionRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Submission ID.
     * @format GUID
     */
    submissionId?: string;
}
export interface SetSubmissionResponse {
    /** Order with submission id */
    order?: Order;
}
