import { NonNullablePaths } from '@wix/sdk-types';
/**
 * An order object includes all of the details related to the purchase of a Pricing Plan.
 * You can manage existing orders, create offline orders, and preview orders not yet purchased.
 *
 * Orders are based on pricing models based on the payment and duration cycles for each plan.
 * Learn more about pricing models ([REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models)|[SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/introduction#pricing-models)).
 */
export interface Order {
    /**
     * Order ID.
     * @format GUID
     * @readonly
     */
    _id?: string;
    /**
     * ID of the plan purchased with the order, from the Plans API.
     * @format GUID
     * @readonly
     */
    planId?: string;
    /**
     * ID of the related Wix subscription.
     *
     * Every pricing plan order corresponds to a Wix subscription, including orders for single payment plans. Learn more in
     * a [Pricing Plans overview](https://support.wix.com/en/article/pricing-plans-an-overview#create-plans-to-suit-your-business).
     * @format GUID
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Wix Pay order ID.
     *
     * Provided by Wix whether the order is created online or offline. The field is omitted when the order is free.
     * @format GUID
     * @readonly
     */
    wixPayOrderId?: string | null;
    /**
     * The buyer's IDs. Includes `memberId` and `contactId`.
     *
     * Currently, Pricing Plan purchases are limited to members only. `contactId` is returned,
     * but a buyer will not be able to purchase a plan without a `memberId`.
     * @readonly
     */
    buyer?: Buyer;
    /**
     * Order pricing model, price, and payment schedule.
     *
     * Learn more about pricing models ([REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models) | [SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/introduction#pricing-models)).
     * @readonly
     */
    pricing?: PricingDetails;
    /**
     * How the order was processed.
     * @readonly
     */
    type?: OrderTypeWithLiterals;
    /**
     * Status of the order.
     * @readonly
     */
    status?: OrderStatusWithLiterals;
    /**
     * Whether the order will be canceled at the next payment date.
     *
     * If `true`, the order status will be `CANCELED` and the next payment won't be charged. Omitted for single payment orders.
     * @readonly
     */
    autoRenewCanceled?: boolean | null;
    /**
     * Details about the cancellation of an order.
     *
     * Only present if the status is `CANCELED`.
     * @readonly
     */
    cancellation?: Cancellation;
    /**
     * Status of the last payment for the order.
     * Updated automatically for online orders. Updated manually by the Wix user for offline orders.
     * @readonly
     */
    lastPaymentStatus?: PaymentStatusWithLiterals;
    /**
     * Start date and time for the ordered plan.
     * @readonly
     */
    startDate?: Date | null;
    /**
     * Current end date and time for the ordered plan.
     *
     * `endDate` may be updated over the course of an order.
     * If the order is paused, it will have a later `endDate` once it is resumed.
     * `endDate` may also be postponed.
     *
     * Omitted if the order is valid until canceled and still `ACTIVE`.
     * @readonly
     */
    endDate?: Date | null;
    /**
     * List of periods during which the order is paused.
     * @readonly
     */
    pausePeriods?: PausePeriod[];
    /**
     * Free trial period for the order, in days.
     *
     * Only available for recurring plans.
     * @readonly
     * @min 1
     * @max 999
     */
    freeTrialDays?: number | null;
    /**
     * Earliest end date and time that the plan for the order can expire.
     *
     * Calculated by using the original end date plus any pause periods. Omitted if the order is active until canceled. Reserved for future use.
     * @readonly
     */
    earliestEndDate?: Date | null;
    /**
     * Current payment cycle for the order.
     *
     * `currentCycle` will be omitted if the order's status is `CANCELED` or `ENDED`, or if the `startDate` hasn't passed yet.
     * @readonly
     */
    currentCycle?: CurrentCycle;
    /**
     * Plan name at the time of purchase.
     * @readonly
     */
    planName?: string;
    /**
     * Plan description at the time of purchase
     * @readonly
     */
    planDescription?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @format DECIMAL_VALUE
     * @readonly
     */
    planPrice?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Information about the form submitted during the plan's checkout.
     * @readonly
     */
    formData?: FormData;
}
export interface Buyer {
    /**
     * Member ID for a Wix site member, from the Members API.
     * @format GUID
     * @readonly
     */
    memberId?: string;
    /**
     * Contact ID for a Wix site contact, from the Contacts API.
     * @format GUID
     * @readonly
     */
    contactId?: string;
}
export interface PriceDetails extends PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Price of the order excluding tax, specified as a monetary amount. for example, `"9.99"`.
     * @format DECIMAL_VALUE
     */
    subtotal?: string;
    /**
     * Total discount applied.
     * @format DECIMAL_VALUE
     */
    discount?: string;
    /** Tax applied. */
    tax?: Tax;
    /**
     * Price after tax and discount is applied, specified as a monetary amount. For example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     * @format DECIMAL_VALUE
     */
    total?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @format DECIMAL_VALUE
     */
    planPrice?: string;
    /**
     * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Free trial period for the order in days. Only available for recurring plans.
     * @min 1
     * @max 999
     */
    freeTrialDays?: number | null;
    /** Coupon applied to the order. Empty means no coupon was applied. */
    coupon?: Coupon;
}
/** @oneof */
export interface PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
export interface Tax {
    /** Name of the tax. For example, VAT. */
    name?: string;
    /** Whether tax is included in the original price. When `false`, tax is added at checkout. */
    includedInPrice?: boolean;
    /**
     * Tax rate percentage, as a number between 0 and 100. For example, a 7% tax rate is `"7.00"`.
     * @format DECIMAL_VALUE
     */
    rate?: string;
    /**
     * Total tax, specified as a monetary amount. For example, `"3.99"`.
     * @format DECIMAL_VALUE
     */
    amount?: string;
}
/** An object specifying how often and for how long payments recur (may be forever). */
export interface Recurrence {
    /**
     * Number of payment cycles the subscription is valid for.
     * `0` for unlimited plans or for plans that are valid until canceled.
     */
    cycleDuration?: Duration;
    /**
     * Length of a payment cycle. For example, 1 month to have monthly payments.
     * Multiply `cycleDuration`'s `count` by `cycleCount` to get the subscription duration.
     * Currently, only a value of `1` is supported.
     * @max 2000
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
export interface Duration {
    /**
     * Number of days, months, weeks, or years in a single payment cycle. Currently limited to support only `1`.
     * @min 1
     */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnitWithLiterals;
}
export declare enum PeriodUnit {
    /** Not defined. */
    UNDEFINED = "UNDEFINED",
    /** Time unit is a day. */
    DAY = "DAY",
    /** Time unit is a week. */
    WEEK = "WEEK",
    /** Time unit is a month. */
    MONTH = "MONTH",
    /** Time unit is a year. */
    YEAR = "YEAR"
}
/** @enumType */
export type PeriodUnitWithLiterals = PeriodUnit | 'UNDEFINED' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
export interface Coupon {
    /**
     * Code of the applied coupon.
     * @minLength 1
     * @maxLength 20
     */
    code?: string;
    /**
     * Total discount of the coupon, as a monetary amount.
     * @format DECIMAL_VALUE
     */
    amount?: string;
    /**
     * Coupon ID.
     * @format GUID
     * @readonly
     */
    _id?: string;
}
export interface PricingDetails extends PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Pricing details for all pricing models.
     * @readonly
     */
    prices?: SpannedPrice[];
}
/** @oneof */
export interface PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
export interface SpannedPrice {
    /**
     * Cycle duration to apply `price` for.
     *
     * Use with all pricing models.
     * Can apply the same price to multiple payment cycles.
     */
    duration?: PriceDuration;
    /** Order price. */
    price?: Price;
}
export interface PriceDuration {
    /**
     * Price starts to apply with this cycle.
     *
     * `1` is the first payment cycle for all pricing models.
     */
    cycleFrom?: number;
    /**
     * Amount of cycles to apply price for.
     *
     * For `subscription` pricing models with a finite number of cycles, the `numberOfCycles` is the same as `pricing.subscription.cycleCount`.
     *
     * For `subscription` pricing models that are unlimited or until-canceled, the `numberOfCycles` is not returned.
     *
     * For `singlePaymentForDuration` and `singlePaymentUnlimited` pricing models, the `numberOfCycles` is `1`.
     */
    numberOfCycles?: number | null;
}
export interface Price {
    /**
     * Price of the order excluding tax, specified as a monetary amount. For example, `"9.99"`.
     * @format DECIMAL_VALUE
     */
    subtotal?: string;
    /** Coupon applied to the order, from the Coupons API. */
    coupon?: Coupon;
    /**
     * Total discount applied to the order.
     * @format DECIMAL_VALUE
     */
    discount?: string;
    /**
     * Tax applied to the order.
     *
     * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
     */
    tax?: Tax;
    /**
     * Price after tax and discount is applied. Specified as a monetary amount, for example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     * @format DECIMAL_VALUE
     */
    total?: string;
    /**
     * Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Price change after billing date was change and price was adjusted. Could be positive and negative values.
     * @format DECIMAL_VALUE
     */
    proration?: string;
}
export interface Fee {
    /**
     * Fee name
     * @minLength 1
     * @maxLength 40
     */
    name?: string;
    /**
     * Amount of fee to be charged
     * @decimalValue options { lt:1000000000000, gt:0.000, maxScale:3 }
     */
    amount?: string;
}
export declare enum OrderType {
    /** Undefined order type. */
    UNDEFINED = "UNDEFINED",
    /** The buyer purchased the plan using the site. */
    ONLINE = "ONLINE",
    /** The buyer made a manual, offline purchase without using the site. */
    OFFLINE = "OFFLINE",
    /** The buyer made a purchase through an external payment provider. */
    EXTERNAL = "EXTERNAL"
}
/** @enumType */
export type OrderTypeWithLiterals = OrderType | 'UNDEFINED' | 'ONLINE' | 'OFFLINE' | 'EXTERNAL';
export declare enum OrderMethod {
    /** Unknown order method. */
    UNKNOWN = "UNKNOWN",
    /** Mail Order / Telephone Order transaction. */
    MOTO = "MOTO",
    /** Point of Sale transaction. */
    POS = "POS"
}
/** @enumType */
export type OrderMethodWithLiterals = OrderMethod | 'UNKNOWN' | 'MOTO' | 'POS';
export declare enum OrderStatus {
    /** Undefined order status. */
    UNDEFINED = "UNDEFINED",
    /** Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer. */
    DRAFT = "DRAFT",
    /** Order has been purchased and its start date is set in the future. */
    PENDING = "PENDING",
    /** Order has been processed. The plan is available for use. */
    ACTIVE = "ACTIVE",
    /** Order, and use of the plan, is paused. The order, and use of the plan, can be resumed. */
    PAUSED = "PAUSED",
    /** Order has completed its duration and is no longer available for use. */
    ENDED = "ENDED",
    /** Order has been canceled. */
    CANCELED = "CANCELED"
}
/** @enumType */
export type OrderStatusWithLiterals = OrderStatus | 'UNDEFINED' | 'DRAFT' | 'PENDING' | 'ACTIVE' | 'PAUSED' | 'ENDED' | 'CANCELED';
export interface Cancellation {
    /** Date and time the cancellation was requested. */
    requestedDate?: Date | null;
    /** Reason for the cancellation. */
    cause?: CancellationCauseWithLiterals;
    /** When the cancellation takes effect. Set when cancelling the order. */
    effectiveAt?: CancellationEffectiveAtWithLiterals;
}
export declare enum CancellationCause {
    /** Undefined cancellation cause. */
    UNDEFINED = "UNDEFINED",
    /** Wix user canceled the order. */
    OWNER_ACTION = "OWNER_ACTION",
    /** Buyer initiated the cancellation. */
    MEMBER_ACTION = "MEMBER_ACTION",
    /** Payment transaction failed. */
    PAYMENT_FAILURE = "PAYMENT_FAILURE",
    /** Buyer's payment details weren't set up correctly. */
    PAYMENT_SETUP_FAILURE = "PAYMENT_SETUP_FAILURE",
    /** Reason for the cancellation is unknown. */
    UNKNOWN = "UNKNOWN"
}
/** @enumType */
export type CancellationCauseWithLiterals = CancellationCause | 'UNDEFINED' | 'OWNER_ACTION' | 'MEMBER_ACTION' | 'PAYMENT_FAILURE' | 'PAYMENT_SETUP_FAILURE' | 'UNKNOWN';
export declare enum CancellationEffectiveAt {
    /** Undefined cancellation time. */
    UNDEFINED = "UNDEFINED",
    /** Cancellation occurs immediately and the buyer can no longer use the plan. */
    IMMEDIATELY = "IMMEDIATELY",
    /** Cancellation occurs at the next payment date and time. Buyer can continue to use the plan until that date and time. */
    NEXT_PAYMENT_DATE = "NEXT_PAYMENT_DATE"
}
/** @enumType */
export type CancellationEffectiveAtWithLiterals = CancellationEffectiveAt | 'UNDEFINED' | 'IMMEDIATELY' | 'NEXT_PAYMENT_DATE';
export declare enum PaymentStatus {
    /** Undefined payment status. */
    UNDEFINED = "UNDEFINED",
    /** Payment has been paid. */
    PAID = "PAID",
    /** Payment has been refunded. */
    REFUNDED = "REFUNDED",
    /** Payment transaction didn't complete. */
    FAILED = "FAILED",
    /** Payment has not been paid. */
    UNPAID = "UNPAID",
    /** Billing has been initialized, but actual charge is yet to be made. This can happen for free trials and payments made with PayPal. */
    PENDING = "PENDING",
    /** No payment was necessary. For example, for free plans or free trials. */
    NOT_APPLICABLE = "NOT_APPLICABLE"
}
/** @enumType */
export type PaymentStatusWithLiterals = PaymentStatus | 'UNDEFINED' | 'PAID' | 'REFUNDED' | 'FAILED' | 'UNPAID' | 'PENDING' | 'NOT_APPLICABLE';
export interface PausePeriod {
    /** Status of the pause period. */
    status?: StatusWithLiterals;
    /** Start date and time of the pause period. */
    pauseDate?: Date | null;
    /**
     * End date and time of the pause period.
     *
     * Omitted while the pause period remains `ACTIVE`.
     */
    resumeDate?: Date | null;
}
export declare enum Status {
    /** Undefined status. */
    UNDEFINED = "UNDEFINED",
    /** Status while the order is paused. */
    ACTIVE = "ACTIVE",
    /** Status when the order is resumed. */
    ENDED = "ENDED"
}
/** @enumType */
export type StatusWithLiterals = Status | 'UNDEFINED' | 'ACTIVE' | 'ENDED';
/**
 * Current cycle will be empty when order is cancelled, expired or order start date is in the future
 * Current cycle start and end dates take into account free trial days and suspensions
 */
export interface CurrentCycle {
    /**
     * Index of the current payment cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for the current payment cycle. */
    startedDate?: Date | null;
    /** End date and time for the current payment cycle. */
    endedDate?: Date | null;
}
/** Order cycle start and end dates take into account free trial days and suspensions */
export interface OrderCycle {
    /**
     * Index of this cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for this order cycle. */
    startedDate?: Date | null;
    /** End date and time for this order cycle. */
    endedDate?: Date | null;
}
export interface FormData {
    /**
     * ID of the order form ([REST](https://dev.wix.com/docs/rest/api-reference/wix-forms/form-submissions/introduction)|[SDK](https://dev.wix.com/docs/sdk/backend-modules/forms/submissions/introduction)) associated with the plan at checkout.
     * @format GUID
     */
    formId?: string | null;
    /**
     * ID of a submission to the plan's order form at checkout. Every time a visitor completes the checkout process for a plan, a new submission is created.
     * @format GUID
     */
    submissionId?: string | null;
    /**
     * Data submitted to the plan's order form at checkout.
     * @readonly
     */
    submissionData?: Record<string, any>;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface Empty {
}
export interface OrderPurchased {
    /** Order that was paid for. If a free or an offline order, the order that was created. */
    order?: Order;
}
export interface OrderStarted {
    /** Order that reached its `startDate`. */
    order?: Order;
}
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook does not trigger at the initial start of an offline order.
 */
export interface OrderCycleStarted {
    /** Order whose new cycle started. */
    order?: Order;
    /** Number of the payment cycle will be 0 when the order is in the free trial period. In other cases, the cycle number starts from 1. */
    cycleNumber?: number;
}
/** Emitted when a recurring order is canceled for the next payment cycle */
export interface OrderAutoRenewCanceled {
    /** Order that is canceled, effective at the end of the current payment cycle. */
    order?: Order;
}
export interface OrderEnded {
    /** Order that ended. */
    order?: Order;
}
export interface GetOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
export declare enum Set {
    /** Same behavior as `BASIC`.` */
    UNKNOWN_SET = "UNKNOWN_SET",
    /** Doesn't return any order form submission data. */
    BASIC = "BASIC",
    /** Returns all order form submission data. */
    FULL = "FULL"
}
/** @enumType */
export type SetWithLiterals = Set | 'UNKNOWN_SET' | 'BASIC' | 'FULL';
export interface GetOrderResponse {
    /** Order. */
    order?: Order;
}
export interface ListOrdersRequest {
    /**
     * Filter by a buyer's member ID, from the Members API.
     * @format GUID
     */
    buyerIds?: string[];
    /**
     * Filter by plan IDs, from the Plans API.
     * @format GUID
     */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatusWithLiterals[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatusWithLiterals[];
    /**
     * Number of orders to return. See Sorting and Paging for more information.
     *
     * Max: `50`
     * @min 1
     * @max 50
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`.
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
export interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
export type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
export interface ListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
export interface OrdersQueryOrdersRequest {
    /** Query filter. */
    query?: QueryV2;
}
export interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
export interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
export interface OrdersQueryOrdersResponse {
    /** Retrieved orders. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface GetOrdersStatsRequest {
}
export interface GetOrdersStatsResponse {
    /** Total number of orders. */
    totalOrderCount?: number;
    /** Number of active orders. */
    activeOrderCount?: number;
}
export interface GetAvailableOrderActionsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id?: string;
}
export interface GetAvailableOrderActionsResponse {
    /** Whether the order can be suspended. */
    suspendable?: boolean;
    /** If the order cannot be suspended, a reason is returned here. */
    notSuspendableReason?: ReasonNotSuspendableWithLiterals;
    /** Whether the order can be canceled by the buyer. */
    cancelableByBuyer?: boolean;
}
export declare enum ReasonNotSuspendable {
    /** Undefined reason. */
    UNDEFINED = "UNDEFINED",
    /** Saved in the database but is awaiting payment. Non-active orders can't be suspended. */
    PENDING = "PENDING",
    /** Trial orders can't be suspended. */
    TRIAL = "TRIAL",
    /** Canceled orders can't be suspended. */
    CANCELED = "CANCELED",
    /** Ended orders can't be suspended. */
    ENDED = "ENDED",
    /** Paid for orders with future start dates can't be suspended. */
    NOT_STARTED = "NOT_STARTED",
    /** Order is already suspended. */
    ALREADY_SUSPENDED = "ALREADY_SUSPENDED",
    /** Orders based on recurring payments using older stripe versions can't be suspended. */
    OLD_STRIPE = "OLD_STRIPE"
}
/** @enumType */
export type ReasonNotSuspendableWithLiterals = ReasonNotSuspendable | 'UNDEFINED' | 'PENDING' | 'TRIAL' | 'CANCELED' | 'ENDED' | 'NOT_STARTED' | 'ALREADY_SUSPENDED' | 'OLD_STRIPE';
export interface PostponeEndDateRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id: string;
    /**
     * New end date and time.
     *
     * Must be later than the current end date and time.
     */
    endDate: Date | null;
}
export interface PostponeEndDateResponse {
}
export interface OrderEndDatePostponed {
    /** Order whose `endDate` was postponed. */
    order?: Order;
}
export interface CancelOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id: string;
    /** __Required.__ When the order will be canceled. One-time orders can only be canceled `IMMEDIATELY`. */
    effectiveAt: CancellationEffectiveAtWithLiterals;
}
export interface CancelOrderResponse {
}
/**
 * Emitted when an order is canceled immediately or when cycle ends for an order with canceled auto renewal
 *
 * To determine the specific reason of the cancellation check `order.cancellation.cause` field.
 */
export interface OrderCanceled {
    /** Canceled order. */
    order?: Order;
}
export interface MarkAsPaidRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id: string;
}
export interface MarkAsPaidResponse {
}
export interface OrderMarkedAsPaid {
    /** Order that was marked as paid. */
    order?: Order;
}
export interface PauseOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id: string;
}
export interface PauseOrderResponse {
}
export interface OrderPaused {
    /** Paused order. */
    order?: Order;
}
export interface BulkPauseOrderRequest {
    /**
     * List of Order IDs.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
export interface BulkPauseOrderResponse {
    /** Orders that were paused. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkOrderResult {
    /** Item metadata */
    itemMetadata?: ItemMetadata;
    /** The order. */
    order?: Order;
}
export interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
export interface ResumeOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id: string;
}
export interface ResumeOrderResponse {
}
export interface OrderResumed {
    /** Resumed order. */
    order?: Order;
}
export interface BulkResumeOrderRequest {
    /**
     * List of Order IDs.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
export interface BulkResumeOrderResponse {
    /** Orders that were resumed. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
export type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
export interface MemberGetOrderRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
export interface MemberGetOrderResponse {
    /** Requested order. */
    order?: Order;
}
export interface MemberListOrdersRequest {
    /**
     * Filter by plan IDs.
     * @format GUID
     */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatusWithLiterals[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatusWithLiterals[];
    /**
     * Limit the number of pricing plans returned. Default limit is 50.
     * @min 1
     * @max 50
     */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
export interface MemberListOrdersResponse {
    /** Requested orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
/**
 * TODO: Write orders filter and sort docs page
 * Retrieves a list of up to 1,000 orders, based on the provided paging, sorting, and filtering.
 */
export interface QueryOrdersRequest {
    /** Query filter. */
    query?: QueryV2;
}
export interface QueryOrdersResponse {
    /** Order data. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface RequestCancellationRequest {
    /**
     * Order ID.
     * @format GUID
     */
    _id: string;
    /** Required. Whether to cancel the order effective immediately or at the next payment date. One-time orders can only be canceled immediately. */
    effectiveAt: CancellationEffectiveAtWithLiterals;
}
export interface RequestCancellationResponse {
}
export interface CreateOnlineOrderRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId: string;
    /**
     * Start date and time for the plan of the online order in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /** Provided if checkout is initiated on buyer's behalf. */
    onBehalf?: OnBehalf;
    /**
     * Submission ID of the form submitted with this order.
     * @format GUID
     */
    submissionId?: string | null;
}
export interface OnBehalf {
    /**
     * Member ID.
     * @format GUID
     */
    memberId?: string;
    /** Method by which checkout is initiated. */
    orderMethod?: OrderMethodWithLiterals;
}
export interface CreateOnlineOrderResponse {
    /** Created online order. */
    order?: Order;
}
export interface CouponsError {
    /** Coupon code. */
    couponCode?: string;
    /** Plan ID. */
    planId?: string;
}
export interface CreateGuestOnlineOrderRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /** Captcha data to prove you are not a robot */
    captcha?: Captcha;
    /** Visitor info */
    guest?: Guest;
    /**
     * Form submission id that was submitted together with the order
     * @format GUID
     */
    submissionId?: string | null;
}
export interface Captcha {
    /** Token from captcha */
    token?: string;
}
export interface Guest {
    /**
     * Email for checkout
     * @format EMAIL
     */
    email?: string;
}
export interface CreateGuestOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
export interface CreateOfflineOrderRequest {
    /**
     * ID of the plan being ordered, from the Plans API.
     * @format GUID
     */
    planId: string;
    /**
     * ID of the member ordering the plan, from the Members API.
     * @format GUID
     */
    memberId: string;
    /**
     * Start date and time for the ordered plan in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /**
     * Form submission ID that was submitted with the order.
     * @format GUID
     */
    submissionId?: string | null;
}
export interface CreateOfflineOrderResponse {
    /** Order. */
    order?: Order;
}
export interface CreateExternalOrderRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId?: string;
    /**
     * Form submission id that was submitted together with the order
     * @format GUID
     */
    submissionId?: string | null;
}
export interface CreateExternalOrderResponse {
    /** Created order */
    order?: Order;
}
export interface GetOnlineOrderPreviewRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId: string;
    /**
     * Start date and time for the plan of the order preview in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
export interface GetOnlineOrderPreviewResponse {
    /** Order preview. This field is undefined if the member has already reached the purchase limit for the order's plan. */
    order?: Order;
    /** Whether the member has already reached purchase limit for the order's plan. */
    purchaseLimitExceeded?: boolean;
}
export interface GetGuestOnlineOrderPreviewRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /**
     * Email for checkout
     * @format EMAIL
     */
    email?: string;
}
export interface GetGuestOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this email.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
export interface GetOfflineOrderPreviewRequest {
    /**
     * ID of the plan of the previewed order, from the Plans API.
     * @format GUID
     */
    planId: string;
    /**
     * Member ID of the buyer the previewed order is for, from the Members API.
     * @format GUID
     */
    memberId: string;
    /**
     * Start date and time for plan of the previewed order in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
export interface GetOfflineOrderPreviewResponse {
    /** The previewed order, as if the plan had been ordered. */
    order?: Order;
    /**
     * Whether this previewed order would exceed the permitted amount of purchases available
     * for this plan for this buyer.
     *
     * Always `false` for plans that do not have purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
export interface GetPricePreviewRequest {
    /**
     * ID of plan to preview.
     * @format GUID
     */
    planId: string;
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
export interface GetPricePreviewResponse {
    /** Pricing details. */
    prices?: SpannedPrice[];
}
export interface ChangeStartDateRequest {
    /**
     * Draft order ID.
     * @format GUID
     */
    orderId?: string;
    /** New valid from date (timestamp). */
    startDate?: Date | null;
}
export interface ChangeStartDateResponse {
    /** Updated draft order. */
    order?: Order;
}
export interface OrderStartDateChanged {
    /** Order whose `startDate` changed. */
    order?: Order;
}
export interface ApplyCouponRequest {
    /**
     * Draft order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string;
}
export interface ApplyCouponResponse {
    /** Order with applied coupon and recalculated tax. */
    order?: Order;
}
export interface SetSubmissionRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Submission ID.
     * @format GUID
     */
    submissionId?: string;
}
export interface SetSubmissionResponse {
    /** Order with submission id */
    order?: Order;
}
export interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
export interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
export interface OrderAutoRenewCanceledEnvelope {
    data: OrderAutoRenewCanceled;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is canceled and `effectiveAt` is set to `NEXT_PAYMENT_DATE`.
 *
 * This webhook is *not* triggered in the following scenarios:
 * + When an order is canceled and `effectiveAt` is set to `IMMEDIATELY`. Instead, at the time of cancellation, Order Canceled is triggered.
 * + When an order expires at the end of the current payment cycle because it was canceled and `effectiveAt` was set to `NEXT_PAYMENT_DATE`. Instead, at the time of expiration, Order Canceled and Order Ended are triggered.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_auto_renew_canceled
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug auto_renew_canceled
 */
export declare function onOrderAutoRenewCanceled(handler: (event: OrderAutoRenewCanceledEnvelope) => void | Promise<void>): void;
export interface OrderCanceledEnvelope {
    data: OrderCanceled;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is canceled.
 *
 * This webhook is triggered either immediately or at the end of the current payment cycle, as follows:
 * + If the order is canceled and `effectiveAt` is set to `IMMEDIATELY`, the webhook is triggered immediately when canceled.
 * + If the order is canceled and `effectiveAt` is set to `NEXT_PAYMENT_DATE`, the webhook is triggered at the end of the current payment cycle. In this case, the Order Auto Renew Canceled Webhook is triggered immediately.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_canceled
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug canceled
 */
export declare function onOrderCanceled(handler: (event: OrderCanceledEnvelope) => void | Promise<void>): void;
export interface OrderCycleStartedEnvelope {
    data: OrderCycleStarted;
    metadata: EventMetadata;
}
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * Not triggered at the initial start of an offline order.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_cycle_started
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug cycle_started
 */
export declare function onOrderCycleStarted(handler: (event: OrderCycleStartedEnvelope) => void | Promise<void>): void;
export interface OrderEndDatePostponedEnvelope {
    data: OrderEndDatePostponed;
    metadata: EventMetadata;
}
/**
 * Triggered when an order's `endDate` is postponed.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_end_date_postponed
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug end_date_postponed
 */
export declare function onOrderEndDatePostponed(handler: (event: OrderEndDatePostponedEnvelope) => void | Promise<void>): void;
export interface OrderEndedEnvelope {
    data: OrderEnded;
    metadata: EventMetadata;
}
/**
 * Triggered when an order ends.
 *
 * This webhook is triggered:
 * + When an order expires at the end of the current payment cycle.
 * + When an order is canceled and `effectiveAt` is set to `IMMEDIATELY`.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_ended
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug ended
 */
export declare function onOrderEnded(handler: (event: OrderEndedEnvelope) => void | Promise<void>): void;
export interface OrderMarkedAsPaidEnvelope {
    data: OrderMarkedAsPaid;
    metadata: EventMetadata;
}
/**
 * Triggered when an offline order is marked as paid.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_marked_as_paid
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug marked_as_paid
 */
export declare function onOrderMarkedAsPaid(handler: (event: OrderMarkedAsPaidEnvelope) => void | Promise<void>): void;
export interface OrderPausedEnvelope {
    data: OrderPaused;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is paused.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_paused
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug paused
 */
export declare function onOrderPaused(handler: (event: OrderPausedEnvelope) => void | Promise<void>): void;
export interface OrderPurchasedEnvelope {
    data: OrderPurchased;
    metadata: EventMetadata;
}
/**
 * Triggered for any of the following purchase events:
 * + Order is paid in full.
 * + At least 1 order cycle payment is paid for.
 * + Offline order is created, even if not yet marked as paid.
 * + Free order is created.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_purchased
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug purchased
 */
export declare function onOrderPurchased(handler: (event: OrderPurchasedEnvelope) => void | Promise<void>): void;
export interface OrderResumedEnvelope {
    data: OrderResumed;
    metadata: EventMetadata;
}
/**
 * Triggered when a paused order is resumed.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_resumed
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug resumed
 */
export declare function onOrderResumed(handler: (event: OrderResumedEnvelope) => void | Promise<void>): void;
export interface OrderStartedEnvelope {
    data: OrderStarted;
    metadata: EventMetadata;
}
/**
 * Triggered when an order reaches its `startDate`. Applies to both purchased and free orders.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_started
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug started
 */
export declare function onOrderStarted(handler: (event: OrderStartedEnvelope) => void | Promise<void>): void;
export interface OrderUpdatedEnvelope {
    entity: Order;
    metadata: EventMetadata;
}
/**
 * Triggered for any of the following update events:
 *
 * + Order is paid for. Order Purchased is also triggered.
 * + Order reaches its start date or end date. Order Started and Order Ended, respectively, are also triggered.
 * + New payment cycle of an order starts. Order Cycle Started is also triggered.
 * + Offline order is marked as paid. Order Marked As Paid is also triggered.
 * + End date of the order is postponed. Order End Date Postponed is also triggered
 * + Order is paused, or a paused order is resumed. Order Paused and Order Resumed, respectively, are also triggered.
 * + Order is canceled, either immediately or at the end of the payment cycle. Order Canceled and Order Auto Renew Canceled, respectively, are also triggered.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_updated
 * @serviceIdentifier com.wixpress.membership.v2.orders.OrderManagementService
 * @slug updated
 */
export declare function onOrderUpdated(handler: (event: OrderUpdatedEnvelope) => void | Promise<void>): void;
export interface OrderCreatedEnvelope {
    entity: Order;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is created.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_created
 * @serviceIdentifier com.wixpress.membership.v2.orders.CheckoutService
 * @slug created
 */
export declare function onOrderCreated(handler: (event: OrderCreatedEnvelope) => void | Promise<void>): void;
export interface OrderStartDateChangedEnvelope {
    data: OrderStartDateChanged;
    metadata: EventMetadata;
}
/**
 * Triggered when an order's `startDate` is changed.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_start_date_changed
 * @serviceIdentifier com.wixpress.membership.v2.orders.CheckoutService
 * @slug start_date_changed
 */
export declare function onOrderStartDateChanged(handler: (event: OrderStartDateChangedEnvelope) => void | Promise<void>): void;
type OrderNonNullablePaths = `_id` | `planId` | `subscriptionId` | `buyer.memberId` | `buyer.contactId` | `priceDetails.subscription.cycleDuration.unit` | `priceDetails.subtotal` | `priceDetails.discount` | `priceDetails.tax.name` | `priceDetails.tax.includedInPrice` | `priceDetails.tax.rate` | `priceDetails.tax.amount` | `priceDetails.total` | `priceDetails.planPrice` | `priceDetails.currency` | `priceDetails.coupon.code` | `priceDetails.coupon.amount` | `priceDetails.coupon._id` | `pricing.subscription.cycleDuration.unit` | `pricing.prices` | `pricing.prices.${number}.duration.cycleFrom` | `pricing.prices.${number}.price.subtotal` | `pricing.prices.${number}.price.coupon.code` | `pricing.prices.${number}.price.coupon.amount` | `pricing.prices.${number}.price.coupon._id` | `pricing.prices.${number}.price.discount` | `pricing.prices.${number}.price.tax.name` | `pricing.prices.${number}.price.tax.includedInPrice` | `pricing.prices.${number}.price.tax.rate` | `pricing.prices.${number}.price.tax.amount` | `pricing.prices.${number}.price.total` | `pricing.prices.${number}.price.currency` | `pricing.prices.${number}.price.proration` | `type` | `status` | `cancellation.cause` | `cancellation.effectiveAt` | `lastPaymentStatus` | `pausePeriods` | `pausePeriods.${number}.status` | `currentCycle.index` | `planName` | `planDescription` | `planPrice`;
/**
 * Retrieves an order by ID.
 * @param _id - Order ID.
 * @public
 * @requiredField _id
 * @param options - Options to use when getting an order.
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.OrderManagementService.GetOrder
 */
export declare function managementGetOrder(_id: string, options?: ManagementGetOrderOptions): Promise<NonNullablePaths<GetOrderResponse, {
    [P in OrderNonNullablePaths]: `order.${P}`;
}[OrderNonNullablePaths]>>;
export interface ManagementGetOrderOptions {
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
/**
 * Retrieves a list of up to 50 pricing plan orders and details, given the specified sorting and filtering.
 *
 * By default, this endpoint will retrieve all orders and return them sorted by `createdDate` in `DESC`, descending order.
 * `sort.fieldName` supports `endDate` and `createdDate` fields and defaults to `ASC`, ascending order.
 * @public
 * @param options - Filtering, sorting, and pagination options.
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.OrderManagementService.ListOrders
 */
export declare function managementListOrders(options?: ManagementListOrdersOptions): Promise<NonNullablePaths<ListOrdersResponse, {
    [P in OrderNonNullablePaths]: `orders.${number}.${P}`;
}[OrderNonNullablePaths]>>;
export interface ManagementListOrdersOptions {
    /**
     * Filter by a buyer's member ID, from the Members API.
     * @format GUID
     */
    buyerIds?: string[];
    /**
     * Filter by plan IDs, from the Plans API.
     * @format GUID
     */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatusWithLiterals[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatusWithLiterals[];
    /**
     * Number of orders to return. See Sorting and Paging for more information.
     *
     * Max: `50`
     * @min 1
     * @max 50
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`.
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
/**
 * Extends the duration of a pricing plan order by postponing the order's `endDate`. Postponing the end date of an order does not impact payments.
 *
 * New `endDate` must be later than the order's current `endDate`. Can't postpone orders that are unlimited.
 * Can't postpone an order with `status`: `PAUSED`.
 * @param _id - Order ID.
 * @param endDate - New end date and time.
 *
 * Must be later than the current end date and time.
 * @public
 * @requiredField _id
 * @requiredField endDate
 * @param options - Options for postponing the end date of an order.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.OrderManagementService.PostponeEndDate
 */
export declare function postponeEndDate(_id: string, endDate: Date): Promise<void>;
/**
 * Cancels an existing order.
 *
 * For orders with recurring payments, a cancellation can be set to occur either `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
 * For orders with one-time payments, a cancellation can only be set for `IMMEDIATELY`.
 *
 * #### Canceling during the free trial period.
 *
 * When a buyer cancels their order during the free trial period, the buyer's subscription expires at the end
 * of the free trial period and they will not be billed. The buyer may continue using the benefits until the end
 * of the free trial period.
 *
 * When a Wix user cancels an ordered plan during the free trial period, they choose whether to apply the cancellation
 * `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`. Canceling `IMMEDIATELY` will end the subscription for the buyer
 * immediately, even during the free trial period and the buyer won't be billed. Canceling at the
 * `NEXT_PAYMENT_DATE` allows the buyer to continue using the benefits of the subscription until the end of the free trial period.
 * Then, the subscription ends and the buyer is not billed.
 * @param _id - Order ID.
 * @param effectiveAt - __Required.__ When the order will be canceled. One-time orders can only be canceled `IMMEDIATELY`.
 * @public
 * @requiredField _id
 * @requiredField effectiveAt
 * @param options - Options for canceling orders.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.OrderManagementService.CancelOrder
 */
export declare function cancelOrder(_id: string, effectiveAt: CancellationEffectiveAtWithLiterals): Promise<void>;
/**
 * Marks an offline order as paid.
 * > __Note__: Marking separate payment cycles as paid is not yet supported. The entire order will be marked as paid. Subsequent offline payments do trigger events and emails, but are not registered as additional offline payments.
 *
 * Marking an offline order as paid causes the following changes:
 * - The order's `lastPaymentStatus` changes to `"PAID"`.
 * - The order's status changes to either `"PENDING"` or `"ACTIVE"`, depending on the order's `startDate`.
 *
 * An error occurs if you attempt to:
 * - Mark an already-paid, offline order as paid. You cannot mark an offline order as paid twice.
 * - Mark an online order as paid. The Mark as Paid method is supported for offline orders only.
 * @param _id - Order ID.
 * @public
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.OrderManagementService.MarkAsPaid
 */
export declare function markAsPaid(_id: string): Promise<void>;
/**
 * Pauses an order. Calling this method changes the order status to `"PAUSED"` and updates the `pausePeriods` array.
 *
 * Only orders with `status`: `ACTIVE` can be paused.
 * For orders with recurring payments, it also pauses the payment schedule. Buyers are not charged when an order is paused.
 * Pausing an order affects the end date of the order by adding the time the order is paused to the `endDate`.
 * The `endDate` and the `earliestEndDate` for the order are adjusted to include the pause period when the order is resumed.
 *
 * To resume a paused order, call Resume Order.
 * @param _id - Order ID.
 * @public
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.OrderManagementService.PauseOrder
 */
export declare function pauseOrder(_id: string): Promise<void>;
/**
 * Resumes a paused order. For orders with recurring payments, it also restarts the payment schedule.
 *
 * Resuming an order causes the following changes:
 * - The order status changes to `"ACTIVE"`.
 * - The `pausePeriods` array is updated.
 * - The `endDate` for the order is adjusted to include the pause period.
 * - For orders with recurring payments, the payment schedule is restarted.
 * - The `earliestEndDate` is adjusted to include the pause period. (This property is reserved for future use).
 *
 * To pause an order, call Pause Order.
 * @param _id - Order ID.
 * @public
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.OrderManagementService.ResumeOrder
 */
export declare function resumeOrder(_id: string): Promise<void>;
/**
 * Retrieves an order for the currently logged-in member by ID.
 * @param _id - Order ID.
 * @public
 * @requiredField _id
 * @param options - Options for getting a logged-in member's order.
 * @permissionId PRICING_PLANS.READ_OWN_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @returns Requested order.
 * @fqn com.wixpress.membership.v2.orders.member.MemberOrdersService.GetOrder
 */
export declare function memberGetOrder(_id: string, options?: MemberGetOrderOptions): Promise<NonNullablePaths<Order, OrderNonNullablePaths>>;
export interface MemberGetOrderOptions {
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
/**
 * Retrieves a list of up to 100 pricing plan orders for currently logged-in member.
 * @public
 * @param options - Filtering, sorting, and pagination options.
 * @permissionId PRICING_PLANS.READ_OWN_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.membership.v2.orders.member.MemberOrdersService.ListOrders
 */
export declare function memberListOrders(options?: MemberListOrdersOptions): Promise<NonNullablePaths<MemberListOrdersResponse, {
    [P in OrderNonNullablePaths]: `orders.${number}.${P}`;
}[OrderNonNullablePaths]>>;
export interface MemberListOrdersOptions {
    /**
     * Filter by plan IDs.
     * @format GUID
     */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatusWithLiterals[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatusWithLiterals[];
    /**
     * Limit the number of pricing plans returned. Default limit is 50.
     * @min 1
     * @max 50
     */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: SetWithLiterals;
}
/**
 * Cancels an order. Recurring orders can be canceled either immediately or at the next payment date. One time orders can only be canceled immediately.
 *
 * There may be some operations that continue to be processed before the status of the order is changed to `"CANCELED"`. For example, payments might need to be refunded before the order is fully canceled.
 *
 * Canceling during the free trial period: When a buyer cancels their order during the free trial period, the buyer's subscription expires at the end of the free trial period and they won't be billed. The buyer may continue using the benefits until the end of the free trial period.
 *
 * >**Note:**
 * >This method requires [visitor or member authentication](https://dev.wix.com/docs/rest/articles/getting-started/access-types-and-permissions).
 * @param _id - Order ID.
 * @param effectiveAt - Required. Whether to cancel the order effective immediately or at the next payment date. One-time orders can only be canceled immediately.
 * @public
 * @requiredField _id
 * @requiredField effectiveAt
 * @param options - Options for requesting a cancellation.
 * @permissionId PRICING_PLANS.MANAGE_OWN_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.membership.v2.orders.member.MemberOrdersService.RequestCancellation
 */
export declare function requestCancellation(_id: string, effectiveAt: CancellationEffectiveAtWithLiterals): Promise<void>;
/**
 * Creates an online order for a site member.
 *
 * If this method is called by a site member ([SDK](https://dev.wix.com/docs/sdk/articles/get-started/about-identities#site-member) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/about-identities#site-member)), the plan is automatically ordered on behalf of that site member. Otherwise, you must specify `onBehalf.memberId` in your call.
 *
 * When an online order is created, but payment hasn't been processed, its status is set to `DRAFT`. After the payment has been processed, if the start date is in the future the order's status is set to `PENDING`. Otherwise, it's set to `ACTIVE`.
 * @param planId - Plan ID.
 * @public
 * @requiredField options.onBehalf.memberId
 * @requiredField planId
 * @fqn com.wixpress.membership.v2.orders.CheckoutService.CreateOnlineOrder
 */
export declare function createOnlineOrder(planId: string, options?: NonNullablePaths<CreateOnlineOrderOptions, `onBehalf.memberId`>): Promise<NonNullablePaths<CreateOnlineOrderResponse, {
    [P in OrderNonNullablePaths]: `order.${P}`;
}[OrderNonNullablePaths]>>;
export interface CreateOnlineOrderOptions {
    /**
     * Start date and time for the plan of the online order in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /** Provided if checkout is initiated on buyer's behalf. */
    onBehalf?: OnBehalf;
    /**
     * Submission ID of the form submitted with this order.
     * @format GUID
     */
    submissionId?: string | null;
}
/**
 * Creates an order for a buyer who purchased the plan with an offline transaction.
 *
 * An offline order is handled off of the Wix site and is marked as `type`: `offline`. If a pricing plan
 * has a limit on the amount of purchases per buyer, that limit is ignored for offline orders.
 * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
 *
 * When creating a free offline order:
 * The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
 * The order's last payment status is set to `"NOT_APPLICABLE"`. "
 *
 * When creating a non-free offline order:
 * The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
 * The order's last payment status is set to `"UNPAID"` or `"PAID"` based on the data passed in the `paid` boolean in the request.
 *
 * Payment for an offline order can be set in 1 of 2 ways:
 * + During order creation, set `paid`: `true`.
 * + After creation, call Mark As Paid.
 * @param planId - ID of the plan being ordered, from the Plans API.
 * @param memberId - ID of the member ordering the plan, from the Members API.
 * @public
 * @requiredField memberId
 * @requiredField planId
 * @param options - Options for creating an offline order.
 * @permissionId PRICING_PLANS.REGISTER_OFFLINE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.CheckoutService.CreateOfflineOrder
 */
export declare function createOfflineOrder(planId: string, memberId: string, options?: CreateOfflineOrderOptions): Promise<NonNullablePaths<CreateOfflineOrderResponse, {
    [P in OrderNonNullablePaths]: `order.${P}`;
}[OrderNonNullablePaths]>>;
export interface CreateOfflineOrderOptions {
    /**
     * Start date and time for the ordered plan in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
    /**
     * Form submission ID that was submitted with the order.
     * @format GUID
     */
    submissionId?: string | null;
}
/**
 * Returns an `order` object that represents a potential online order for a site member.
 *
 * You can use this method to show a site member a preview of an online order before [creating](https://dev.wix.com/docs/rest/business-solutions/pricing-plans/pricing-plans/orders/create-online-order) it.
 *
 * This method must be called using the site member identity ([SDK](https://dev.wix.com/docs/sdk/articles/get-started/about-identities#site-member) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/about-identities#site-member)). Therefore, [Wix apps](https://dev.wix.com/docs/build-apps) can't currently call this method using REST.
 * @param planId - Plan ID.
 * @public
 * @requiredField planId
 * @permissionId PRICING_PLANS.PURCHASE_PLANS
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.membership.v2.orders.CheckoutService.GetOnlineOrderPreview
 */
export declare function getOnlineOrderPreview(planId: string, options?: GetOnlineOrderPreviewOptions): Promise<NonNullablePaths<GetOnlineOrderPreviewResponse, {
    [P in OrderNonNullablePaths]: `order.${P}`;
}[OrderNonNullablePaths] | `purchaseLimitExceeded`>>;
export interface GetOnlineOrderPreviewOptions {
    /**
     * Start date and time for the plan of the order preview in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
/**
 * Performs a dry run of a purchase and provides an order preview.
 *
 * The preview uses the same logic as purchasing a plan, but the preview is not saved. Because an order is not actually
 * created, the preview order's `orderId` and `subscriptionId` are displayed as a string of multiple zero characters
 * (`000000-0000`). Tax is only calculated if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
 * <br>
 * If a pricing plan has a limit on the amount of purchases per buyer, that limit is not considered for generating the preview.
 * But, if that limit has been reached and this order would then exceed the amount of purchases permitted for this buyer, then
 * `purchaseLimitExceeded` will return as `true`.
 *
 * To get a general price preview for a plan that's not buyer-specific, call Get Price Preview.
 * @param memberId - Member ID of the buyer the previewed order is for, from the Members API.
 * @public
 * @requiredField memberId
 * @requiredField planId
 * @param options - Options for previewing the offline order.
 * @param planId - ID of the plan of the previewed order.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.membership.v2.orders.CheckoutService.GetOfflineOrderPreview
 */
export declare function getOfflineOrderPreview(planId: string, memberId: string, options?: GetOfflineOrderPreviewOptions): Promise<NonNullablePaths<GetOfflineOrderPreviewResponse, {
    [P in OrderNonNullablePaths]: `order.${P}`;
}[OrderNonNullablePaths] | `purchaseLimitExceeded`>>;
export interface GetOfflineOrderPreviewOptions {
    /**
     * Start date and time for plan of the previewed order in a `YYYY-MM-DDThh:mm[:ss][.sss]Z` format.
     *
     * Default: Current date and time.
     */
    startDate?: Date | null;
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
/**
 * Retrieves a plan's pricing.
 *
 * The price preview uses the same logic as purchasing a plan, but the preview is not saved. Tax is only applied if
 * the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection). The price is returned
 * in the pricing model format used for orders. Learn more about pricing models ([REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models)|[SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/introduction#pricing-models)).
 *
 * Buyers do not have to be logged in to preview the price, and as such, the details returned are not buyer-specific. To
 * generate a preview of a purchase for a specific buyer, call Get Offline Order Preview.
 * @param planId - ID of plan to preview.
 * @public
 * @requiredField planId
 * @param options - Options for getting a price preview.
 * @permissionId PRICING_PLANS.READ_PUBLIC_PLANS
 * @permissionScope Read Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-PLANS
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.membership.v2.orders.CheckoutService.GetPricePreview
 */
export declare function getPricePreview(planId: string, options?: GetPricePreviewOptions): Promise<NonNullablePaths<GetPricePreviewResponse, `price.subscription.cycleDuration.unit` | `price.subtotal` | `price.discount` | `price.tax.name` | `price.tax.includedInPrice` | `price.tax.rate` | `price.tax.amount` | `price.total` | `price.planPrice` | `price.currency` | `price.coupon.code` | `price.coupon.amount` | `price.coupon._id` | `prices` | `prices.${number}.duration.cycleFrom` | `prices.${number}.price.subtotal` | `prices.${number}.price.coupon.code` | `prices.${number}.price.coupon.amount` | `prices.${number}.price.coupon._id` | `prices.${number}.price.discount` | `prices.${number}.price.tax.name` | `prices.${number}.price.tax.includedInPrice` | `prices.${number}.price.tax.rate` | `prices.${number}.price.tax.amount` | `prices.${number}.price.total` | `prices.${number}.price.currency` | `prices.${number}.price.proration`>>;
export interface GetPricePreviewOptions {
    /**
     * Coupon code to apply, from the Coupons API.
     * @minLength 1
     * @maxLength 20
     */
    couponCode?: string | null;
}
export {};
